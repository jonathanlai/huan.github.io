<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Android系统启动流程之Linux内核 | Jona's Blog</title><meta name="author" content="赖兴兵"><meta name="copyright" content="赖兴兵"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#FFFBFF"><meta name="description" content="Android本质上就是一个基于Linux内核的操作系统，与Ubuntu Linux、Fedora Linux类似，我们要讲Android，必定先要了解一些Linux内核的知识。Linux内核的东西特别多，我也不可能全部讲完，由于本文主要讲解Android系统启动流程，所以这里主要讲一些内核启动相关的知识。Linux内核启动主要涉及3个特殊的进程，idle进程(PID &#x3D; 0), init进程(P">
<meta property="og:type" content="article">
<meta property="og:title" content="Android系统启动流程之Linux内核">
<meta property="og:url" content="http://huanyuan.mobi/202202/android/foxleezh-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BLinux%E5%86%85%E6%A0%B8.html">
<meta property="og:site_name" content="Jona&#39;s Blog">
<meta property="og:description" content="Android本质上就是一个基于Linux内核的操作系统，与Ubuntu Linux、Fedora Linux类似，我们要讲Android，必定先要了解一些Linux内核的知识。Linux内核的东西特别多，我也不可能全部讲完，由于本文主要讲解Android系统启动流程，所以这里主要讲一些内核启动相关的知识。Linux内核启动主要涉及3个特殊的进程，idle进程(PID &#x3D; 0), init进程(P">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://huanyuan.mobi/imgs/202202/6a46ae1ab70f1a5c15a863a5372e694a_MD5.png">
<meta property="article:published_time" content="2022-02-12T11:05:00.000Z">
<meta property="article:modified_time" content="2023-03-14T01:17:11.512Z">
<meta property="article:author" content="赖兴兵">
<meta property="article:tag" content="Android">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://huanyuan.mobi/imgs/202202/6a46ae1ab70f1a5c15a863a5372e694a_MD5.png"><link rel="shortcut icon" href="/imgs/avatar.jpg"><link rel="canonical" href="http://huanyuan.mobi/202202/android/foxleezh-Android%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E4%B9%8BLinux%E5%86%85%E6%A0%B8.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-i31VjpiWuu"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5fba8e4140079c36623565d1c9885852";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-0GBY2PNEKY"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', '[object Object]');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Android系统启动流程之Linux内核',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-14 09:17:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#1C1B1E')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#FFFBFF')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/imgs/avatar.jpg" onerror="onerror=null;src='/imgs/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-compass"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-coffee"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 照片墙</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-user-friends"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/imgs/202202/6a46ae1ab70f1a5c15a863a5372e694a_MD5.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Jona's Blog"><span class="site-name">Jona's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-compass"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-coffee"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 照片墙</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-user-friends"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Android系统启动流程之Linux内核</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-12T11:05:00.000Z" title="发表于 2022-02-12 19:05:00">2022-02-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-14T01:17:11.512Z" title="更新于 2023-03-14 09:17:11">2023-03-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/">Android</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Android/%E6%BA%90%E7%A0%81/">源码</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Android系统启动流程之Linux内核"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android本质上就是一个基于Linux内核的操作系统，与Ubuntu Linux、Fedora Linux类似，我们要讲Android，必定先要了解一些Linux内核的知识。</p>
<p>Linux内核的东西特别多，我也不可能全部讲完，由于本文主要讲解Android系统启动流程，所以这里主要讲一些内核启动相关的知识。</p>
<p>Linux内核启动主要涉及3个特殊的进程，idle进程(PID &#x3D; 0), init进程(PID &#x3D; 1)和kthreadd进程(PID &#x3D; 2)，这三个进程是内核的基础。</p>
<ul>
<li>idle进程是Linux系统第一个进程，是init进程和kthreadd进程的父进程</li>
<li>init进程是Linux系统第一个用户进程，是Android系统应用程序的始祖，我们的app都是直接或间接以它为父进程</li>
<li>kthreadd进程是Linux系统内核管家，所有的内核线程都是直接或间接以它为父进程</li>
</ul>
<p><img src="/imgs/202202/6a46ae1ab70f1a5c15a863a5372e694a_MD5.png"></p>
<p>本文将以这三个进程为线索，主要讲解以下内容：</p>
<ul>
<li>idle进程启动</li>
<li>kthreadd进程启动</li>
<li>init进程启动</li>
</ul>
<p>本文涉及到的文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">msm/arch/arm64/kernel/head.S</span><br><span class="line">msm/init/main.c</span><br><span class="line">msm/kernel/rcutree.c</span><br><span class="line">msm/kernel/fork.c</span><br><span class="line">msm/mm/mempolicy.c</span><br><span class="line">msm/kernel/kthread.c</span><br><span class="line">msm/include/linux/kthread.h</span><br><span class="line">msm/include/linux/rcupdate.h</span><br><span class="line">msm/kernel/rcupdate.c</span><br><span class="line">msm/kernel/pid.c</span><br><span class="line">msm/include/linux/sched.h</span><br><span class="line">msm/kernel/sched/core.c</span><br><span class="line">msm/kernel/cpu/idle.c</span><br><span class="line">msm/drivers/base/init.c</span><br></pre></td></tr></table></figure>

<h2 id="一、idle进程启动"><a href="#一、idle进程启动" class="headerlink" title="一、idle进程启动"></a>一、idle进程启动</h2><p>很多文章讲Android都从init进程讲起，它的进程号是1，既然进程号是1，那么有没有进程号是0的进程呢，其实是有的。</p>
<p>这个进程名字叫init_task，后期会退化为idle，它是Linux系统的第一个进程(init进程是第一个用户进程)，也是唯一一个没有通过fork或者kernel_thread产生的进程，它在完成初始化操作后，主要负责进程调度、交换。</p>
<p>idle进程的启动是用汇编语言写的，对应文件是msm&#x2F;arch&#x2F;arm64&#x2F;kernel&#x2F;head.S，因为都是用汇编语言写的，我就不多介绍了，具体可参考 <a target="_blank" rel="noopener" href="http://blog.csdn.net/forever_2015/article/details/52885250">kernel 启动流程之head.S</a> ,这里面有一句比较重要</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">340 	str	x22, [x4]			// Save processor ID</span><br><span class="line">341 	str	x21, [x5]			// Save FDT pointer</span><br><span class="line">342 	str	x24, [x6]			// Save PHYS_OFFSET</span><br><span class="line">343 	mov	x29, #0</span><br><span class="line">344 	b	start_kernel        //跳转start_kernel函数</span><br></pre></td></tr></table></figure>
<p>第344行，b start_kernel，b 就是跳转的意思，跳转到start_kernel.h，这个头文件对应的实现在msm&#x2F;init&#x2F;main.c，start_kernel函数在最后会调用rest_init函数，这个函数开启了init进程和kthreadd进程，我们着重分析下rest_init函数。</p>
<p>在讲源码前，我先说明下我分析源码的写作风格：</p>
<ul>
<li>一般我会在函数下面写明该函数所在的位置，比如定义在msm&#x2F;init&#x2F;main.c中，这样大家就可以去项目里找到源文件</li>
<li>我会把源码相应的英文注释也一并copy进来，这样方便英文好的人可以看到原作者的注释</li>
<li>我会尽可能将函数中每一行代码的作用注释下(一般以&#x2F;&#x2F;的形式注释在代码结尾)，大家在看源码的同时就可以理解这段代码作用，这也是我花时间最多的,请大家务必认真看。我也想过在源码外部统一通过行号来解释，但是感觉这样需要大家一会儿看源码，一会儿看解释，上下来回看不方便，所以干脆写在一起了</li>
<li>为了大家更好地阅读注释，我会手动做换行处理，&#x2F;&#x2F;形式注释可能会换行到句首，也就是可能会出现在代码下方</li>
<li>在函数结尾我尽可能总结下这个函数做了些什么，以及这个函数涉及到的一些知识</li>
<li>对于重要的函数，我会将函数中每一个调用的子函数再单独拿出来讲解</li>
<li>考虑到大家都是开发Android的比较多，对C&#x2F;C++不太了解，在注释中我也会讲一些C&#x2F;C++的知识，方便大家理解，C语言注释我一般用&#x2F;** *&#x2F;的形式注释在代码顶头</li>
<li>为了更好的阅读体验，希望大家可以下载一下Source Insight同步看代码，<a target="_blank" rel="noopener" href="https://juejin.im/post/59ec35f8f265da4307026b79">使用教程</a> ,可以直接将<a target="_blank" rel="noopener" href="https://github.com/foxleezh/AOSP">项目</a>中app&#x2F;src&#x2F;main&#x2F;cpp作为目录加入到Source Insight中</li>
</ul>
<h3 id="1-1-rest-init"><a href="#1-1-rest-init" class="headerlink" title="1.1 rest_init"></a>1.1 rest_init</h3><p>定义在msm&#x2F;init&#x2F;main.c中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 1.C语言oninline与inline是一对意义相反的关键字，inline的作用是编译期间直接替换代码块，也就是说编译后就没有这个方法了，</span><br><span class="line"> * 而是直接把代码块替换调用这个函数的地方，oninline就相反，强制不替换，保持原有的函数</span><br><span class="line"> * 2.__init_refok是__init的扩展，__init 定义的初始化函数会放入名叫.init.text的输入段，当内核启动完毕后，</span><br><span class="line"> * 这个段中的内存会被释放掉，在本文中有讲，关注3.5 free_initmem</span><br><span class="line"> * 3.不带参数的方法会加一个void参数</span><br><span class="line"> */</span><br><span class="line">static noinline void __init_refok rest_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	int pid;</span><br><span class="line">	/*</span><br><span class="line">	 * 1.C语言中const相当于Java中的final static， 表示常量</span><br><span class="line">	 * 2.struct是结构体，相当于Java中定义了一个实体类，里面只有一些成员变量，&#123;.sched_priority =1 &#125;相当于new，</span><br><span class="line">	 * 然后将成员变量sched_priority的值赋为1</span><br><span class="line">	 */</span><br><span class="line">	const struct sched_param param = &#123; .sched_priority = 1 &#125;; //初始化优先级为1的进程调度策略，</span><br><span class="line">	//取值1~99，1为最小</span><br><span class="line"></span><br><span class="line">	rcu_scheduler_starting(); //启动RCU机制，这个与后面的rcu_read_lock和rcu_read_unlock是配套的，用于多核同步</span><br><span class="line">	/*</span><br><span class="line">	 * We need to spawn init first so that it obtains pid 1, however</span><br><span class="line">	 * the init task will end up wanting to create kthreads, which, if</span><br><span class="line">	 * we schedule it before we create kthreadd, will OOPS.</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">     * 1.C语言中支持方法传参，kernel_thread是函数，kernel_init也是函数，但是kernel_init却作为参数传递了过去，</span><br><span class="line">     * 其实传递过去的是一个函数指针,参考[函数指针](http://www.cnblogs.com/haore147/p/3647262.html)</span><br><span class="line">     * 2.CLONE_FS这种大写的一般就是常量了，跟Java差不多</span><br><span class="line">     */</span><br><span class="line">	kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND); //用kernel_thread方式创建init进程，</span><br><span class="line">	//CLONE_FS 子进程与父进程共享相同的文件系统，包括root、当前目录、umask，</span><br><span class="line">	//CLONE_SIGHAND  子进程与父进程共享相同的信号处理（signal handler）表</span><br><span class="line"></span><br><span class="line">	numa_default_policy(); // 设定NUMA系统的默认内存访问策略</span><br><span class="line">	pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);//用kernel_thread方式创建kthreadd进程，</span><br><span class="line">	//CLONE_FILES  子进程与父进程共享相同的文件描述符（file descriptor）表</span><br><span class="line"></span><br><span class="line">	rcu_read_lock(); //打开RCU读取锁，在此期间无法进行进程切换</span><br><span class="line">	/*</span><br><span class="line">	 * C语言中&amp;的作用是获得变量的内存地址，参考[C指针](http://www.runoob.com/cprogramming/c-pointers.html)</span><br><span class="line">	 */</span><br><span class="line">	kthreadd_task = find_task_by_pid_ns(pid, &amp;init_pid_ns);// 获取kthreadd的进程描述符，</span><br><span class="line">	//期间需要检索进程pid的使用链表，所以要加锁</span><br><span class="line"></span><br><span class="line">	rcu_read_unlock(); //关闭RCU读取锁</span><br><span class="line">	sched_setscheduler_nocheck(kthreadd_task, SCHED_FIFO, &amp;param); //设置kthreadd的进程调度策略，</span><br><span class="line">	//SCHED_FIFO 实时调度策略，即马上调用，先到先服务，param的优先级之前定义为1</span><br><span class="line"></span><br><span class="line">	complete(&amp;kthreadd_done); // complete和wait_for_completion是配套的同步机制，跟java的notify和wait差不多，</span><br><span class="line">	//之前kernel_init函数调用了wait_for_completion(&amp;kthreadd_done)，</span><br><span class="line">	//这里调用complete就是通知kernel_init进程kthreadd进程已创建完成，可以继续执行</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * The boot idle thread must execute schedule()</span><br><span class="line">	 * at least once to get things moving:</span><br><span class="line">	 */</span><br><span class="line">	init_idle_bootup_task(current);//current表示当前进程，当前0号进程init_task设置为idle进程</span><br><span class="line">	schedule_preempt_disabled(); //0号进程主动请求调度，让出cpu，1号进程kernel_init将会运行,并且禁止抢占</span><br><span class="line">	/* Call into cpu_idle with preempt disabled */</span><br><span class="line">	cpu_startup_entry(CPUHP_ONLINE);// 这个函数会调用cpu_idle_loop()使得idle进程进入自己的事件处理循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rest_init的字面意思是剩余的初始化，但是它却一点都不剩余，它创建了Linux系统中两个重要的进程init和kthreadd，并且将init_task进程变为idle进程，接下来我将把rest_init中的方法逐个解析，方便大家理解。</p>
<h3 id="1-2-rcu-scheduler-starting"><a href="#1-2-rcu-scheduler-starting" class="headerlink" title="1.2 rcu_scheduler_starting"></a>1.2 rcu_scheduler_starting</h3><p>定义在msm&#x2F;kernel&#x2F;rcutree.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * This function is invoked towards the end of the scheduler&#x27;s initialization</span><br><span class="line"> * process.  Before this is called, the idle task might contain</span><br><span class="line"> * RCU read-side critical sections (during which time, this idle</span><br><span class="line"> * task is booting the system).  After this function is called, the</span><br><span class="line"> * idle tasks are prohibited from containing RCU read-side critical</span><br><span class="line"> * sections.  This function also enables RCU lockdep checking.</span><br><span class="line"> */</span><br><span class="line">void rcu_scheduler_starting(void)</span><br><span class="line">&#123;</span><br><span class="line">	WARN_ON(num_online_cpus() != 1); //WARN_ON相当于警告，会打印出当前栈信息，不会重启，</span><br><span class="line">	//num_online_cpus表示当前启动的cpu数</span><br><span class="line"></span><br><span class="line">	WARN_ON(nr_context_switches() &gt; 0); // nr_context_switches 进行进程切换的次数</span><br><span class="line">	rcu_scheduler_active = 1; //启用rcu机制</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-kernel-thread"><a href="#1-3-kernel-thread" class="headerlink" title="1.3 kernel_thread"></a>1.3 kernel_thread</h3><p>定义在msm&#x2F;kernel&#x2F;fork.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Create a kernel thread.</span><br><span class="line"> */</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * 1.C语言中 int (*fn)(void *)表示函数指针的定义，int是返回值，void是函数的参数，fn是名字</span><br><span class="line"> * 2.C语言中 * 表示指针，这个用法很多</span><br><span class="line"> * 3.unsigned表示无符号，一般与long,int,char等结合使用，表示范围只有正数，</span><br><span class="line"> * 比如init表示范围-2147483648～2147483647 ，那unsigned表示范围0～4294967295，足足多了一倍</span><br><span class="line"> */</span><br><span class="line">pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)</span><br><span class="line">&#123;</span><br><span class="line">	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, (unsigned long)fn,</span><br><span class="line">		(unsigned long)arg, NULL, NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>do_fork函数用于创建进程，它首先调用copy_process()创建新进程，然后调用wake_up_new_task()将进程放入运行队列中并启动新进程。<br>kernel_thread的第一个参数是一个函数引用，它相当于Java中的构造函数，会在创建进程后执行，第三个参数是创建进程的方式，具体如下：</p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="left">CLONE_PARENT</td>
<td align="left">创建的子进程的父进程是调用者的父进程，新进程与创建它的进程成了“兄弟”而不是“父子”</td>
</tr>
<tr>
<td align="left">CLONE_FS</td>
<td align="left">子进程与父进程共享相同的文件系统，包括root、当前目录、umask</td>
</tr>
<tr>
<td align="left">CLONE_FILES</td>
<td align="left">子进程与父进程共享相同的文件描述符（file descriptor）表</td>
</tr>
<tr>
<td align="left">CLONE_NEWNS</td>
<td align="left">在新的namespace启动子进程，namespace描述了进程的文件hierarchy</td>
</tr>
<tr>
<td align="left">CLONE_SIGHAND</td>
<td align="left">子进程与父进程共享相同的信号处理（signal handler）表</td>
</tr>
<tr>
<td align="left">CLONE_PTRACE</td>
<td align="left">若父进程被trace，子进程也被trace</td>
</tr>
<tr>
<td align="left">CLONE_UNTRACED</td>
<td align="left">若父进程被trace，子进程不被trace</td>
</tr>
<tr>
<td align="left">CLONE_VFORK</td>
<td align="left">父进程被挂起，直至子进程释放虚拟内存资源</td>
</tr>
<tr>
<td align="left">CLONE_VM</td>
<td align="left">子进程与父进程运行于相同的内存空间</td>
</tr>
<tr>
<td align="left">CLONE_PID</td>
<td align="left">子进程在创建时PID与父进程一致</td>
</tr>
<tr>
<td align="left">CLONE_THREAD</td>
<td align="left">Linux 2.4中增加以支持POSIX线程标准，子进程与父进程共享相同的线程群</td>
</tr>
</tbody></table>
<h3 id="1-4-kernel-init"><a href="#1-4-kernel-init" class="headerlink" title="1.4 kernel_init"></a>1.4 kernel_init</h3><p>定义在msm&#x2F;init&#x2F;main.c</p>
<p>这个函数比较重要，负责init进程的启动，我将放在第三节重点讲，这个函数首先调用kernel_init_freeable函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static noinline void __init kernel_init_freeable(void)</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">	 * Wait until kthreadd is all set-up.</span><br><span class="line">	 */</span><br><span class="line">	wait_for_completion(&amp;kthreadd_done);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait_for_completion之前讲了，与complete是配套的同步机制，这里就是等待&amp;kthreadd_done这个值complete，然后就可以继续执行</p>
<h3 id="1-5-numa-default-policy"><a href="#1-5-numa-default-policy" class="headerlink" title="1.5 numa_default_policy"></a>1.5 numa_default_policy</h3><p>定义在msm&#x2F;mm&#x2F;mempolicy.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Reset policy of current process to default */</span><br><span class="line">void numa_default_policy(void)</span><br><span class="line">&#123;</span><br><span class="line">	do_set_mempolicy(MPOL_DEFAULT, 0, NULL); //设定NUMA系统的内存访问策略为MPOL_DEFAULT</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-kthreadd"><a href="#1-6-kthreadd" class="headerlink" title="1.6 kthreadd"></a>1.6 kthreadd</h3><p>定义在msm&#x2F;kernel&#x2F;kthread.c中</p>
<p>kthreadd进程我将在第二节中重点讲，它是内核中重要的进程，负责内核线程的调度和管理，内核线程基本都是以它为父进程的</p>
<h3 id="1-7-rcu-read-lock-amp-rcu-read-unlock"><a href="#1-7-rcu-read-lock-amp-rcu-read-unlock" class="headerlink" title="1.7 rcu_read_lock &amp; rcu_read_unlock"></a>1.7 rcu_read_lock &amp; rcu_read_unlock</h3><p>定义在msm&#x2F;include&#x2F;linux&#x2F;rcupdate.h和msm&#x2F;kernel&#x2F;rcupdate.c中</p>
<p>RCU（Read-Copy Update）是数据同步的一种方式，在当前的Linux内核中发挥着重要的作用。RCU主要针对的数据对象是链表，目的是提高遍历读取数据的效率，为了达到目的使用RCU机制读取数据的时候不对链表进行耗时的加锁操作。这样在同一时间可以有多个线程同时读取该链表，并且允许一个线程对链表进行修改（修改的时候，需要加锁）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">static inline void rcu_read_lock(void)</span><br><span class="line">&#123;</span><br><span class="line">	__rcu_read_lock();</span><br><span class="line">	__acquire(RCU);</span><br><span class="line">	rcu_lock_acquire(&amp;rcu_lock_map);</span><br><span class="line">	rcu_lockdep_assert(!rcu_is_cpu_idle(),</span><br><span class="line">			   &quot;rcu_read_lock() used illegally while idle&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void rcu_read_unlock(void)</span><br><span class="line">&#123;</span><br><span class="line">	rcu_lockdep_assert(!rcu_is_cpu_idle(),</span><br><span class="line">			   &quot;rcu_read_unlock() used illegally while idle&quot;);</span><br><span class="line">	rcu_lock_release(&amp;rcu_lock_map);</span><br><span class="line">	__release(RCU);</span><br><span class="line">	__rcu_read_unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-8-find-task-by-pid-ns"><a href="#1-8-find-task-by-pid-ns" class="headerlink" title="1.8 find_task_by_pid_ns"></a>1.8 find_task_by_pid_ns</h3><p>定义在msm&#x2F;kernel&#x2F;pid.c中</p>
<p>task_struct叫进程描述符，这个结构体包含了一个进程所需的所有信息，它定义在msm&#x2F;include&#x2F;linux&#x2F;sched.h文件中。</p>
<p>它的结构十分复杂，本文就不重点讲了，可以参考<a target="_blank" rel="noopener" href="http://blog.csdn.net/gatieme/article/details/51383272">Linux进程描述符task_struct结构体详解</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Must be called under rcu_read_lock().</span><br><span class="line"> */</span><br><span class="line">struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line">	rcu_lockdep_assert(rcu_read_lock_held(),</span><br><span class="line">			   &quot;find_task_by_pid_ns() needs rcu_read_lock()&quot;</span><br><span class="line">			   &quot; protection&quot;); //必须进行RCU加锁</span><br><span class="line">	return pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct pid *find_pid_ns(int nr, struct pid_namespace *ns)</span><br><span class="line">&#123;</span><br><span class="line">	struct upid *pnr;</span><br><span class="line"></span><br><span class="line">	hlist_for_each_entry_rcu(pnr,</span><br><span class="line">			&amp;pid_hash[pid_hashfn(nr, ns)], pid_chain)</span><br><span class="line">			/*</span><br><span class="line">			 * C语言中 -&gt; 用于指向结构体 struct 中的数据</span><br><span class="line">			 */</span><br><span class="line">		if (pnr-&gt;nr == nr &amp;&amp; pnr-&gt;ns == ns)</span><br><span class="line">			return container_of(pnr, struct pid,</span><br><span class="line">					numbers[ns-&gt;level]); //遍历hash表，找到struct pid</span><br><span class="line"></span><br><span class="line">	return NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct task_struct *pid_task(struct pid *pid, enum pid_type type)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *result = NULL;</span><br><span class="line">	if (pid) &#123;</span><br><span class="line">		struct hlist_node *first;</span><br><span class="line">		first = rcu_dereference_check(hlist_first_rcu(&amp;pid-&gt;tasks[type]),</span><br><span class="line">					      lockdep_tasklist_lock_is_held());</span><br><span class="line">		if (first)</span><br><span class="line">			result = hlist_entry(first, struct task_struct, pids[(type)].node); //从hash表中找出struct task_struct</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>find_task_by_pid_ns的作用就是根据pid，在hash表中获得对应pid的task_struct</p>
<h3 id="1-9-sched-setscheduler-nocheck"><a href="#1-9-sched-setscheduler-nocheck" class="headerlink" title="1.9 sched_setscheduler_nocheck"></a>1.9 sched_setscheduler_nocheck</h3><p>定义在msm&#x2F;kernel&#x2F;sched&#x2F;core.c中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int sched_setscheduler_nocheck(struct task_struct *p, int policy,</span><br><span class="line">			       const struct sched_param *param)</span><br><span class="line">&#123;</span><br><span class="line">	struct sched_attr attr = &#123;</span><br><span class="line">		.sched_policy   = policy,</span><br><span class="line">		.sched_priority = param-&gt;sched_priority</span><br><span class="line">	&#125;;</span><br><span class="line">	return __sched_setscheduler(p, &amp;attr, false); //设置进程调度策略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>linux内核目前实现了6种调度策略(即调度算法), 用于对不同类型的进程进行调度, 或者支持某些特殊的功能</p>
<ul>
<li>SCHED_FIFO和SCHED_RR和SCHED_DEADLINE则采用不同的调度策略调度实时进程，优先级最高</li>
<li>SCHED_NORMAL和SCHED_BATCH调度普通的非实时进程，优先级普通</li>
<li>SCHED_IDLE则在系统空闲时调用idle进程，优先级最低</li>
</ul>
<h3 id="1-10-init-idle-bootup-task"><a href="#1-10-init-idle-bootup-task" class="headerlink" title="1.10 init_idle_bootup_task"></a>1.10 init_idle_bootup_task</h3><p>定义在msm&#x2F;kernel&#x2F;sched&#x2F;core.c中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void __cpuinit init_idle_bootup_task(struct task_struct *idle)</span><br><span class="line">&#123;</span><br><span class="line">	idle-&gt;sched_class = &amp;idle_sched_class; //设置进程的调度器类为idle_sched_class</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Linux依据其调度策略的不同实现了5个调度器类, 一个调度器类可以用一种种或者多种调度策略调度某一类进程, 也可以用于特殊情况或者调度特殊功能的进程.</p>
<p>其所属进程的优先级顺序为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stop_sched_class -&gt; dl_sched_class -&gt; rt_sched_class -&gt; fair_sched_class -&gt; idle_sched_class</span><br></pre></td></tr></table></figure>
<p>可见idle_sched_class的优先级最低，只有系统空闲时才调用idle进程</p>
<h3 id="1-11-schedule-preempt-disabled"><a href="#1-11-schedule-preempt-disabled" class="headerlink" title="1.11 schedule_preempt_disabled"></a>1.11 schedule_preempt_disabled</h3><p>定义在msm&#x2F;kernel&#x2F;sched&#x2F;core.c中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * schedule_preempt_disabled - called with preemption disabled</span><br><span class="line"> *</span><br><span class="line"> * Returns with preemption disabled. Note: preempt_count must be 1</span><br><span class="line"> */</span><br><span class="line">void __sched schedule_preempt_disabled(void)</span><br><span class="line">&#123;</span><br><span class="line">	sched_preempt_enable_no_resched(); //开启内核抢占</span><br><span class="line">	schedule();  // 并主动请求调度，让出cpu</span><br><span class="line">	preempt_disable(); // 关闭内核抢占</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.9到1.11都涉及到Linux的进程调度问题，可以参考 <a target="_blank" rel="noopener" href="http://blog.csdn.net/gatieme/article/details/51872618">Linux用户抢占和内核抢占详解</a></p>
<h3 id="1-12-cpu-startup-entry"><a href="#1-12-cpu-startup-entry" class="headerlink" title="1.12 cpu_startup_entry"></a>1.12 cpu_startup_entry</h3><p>定义在msm&#x2F;kernel&#x2F;cpu&#x2F;idle.c中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void cpu_startup_entry(enum cpuhp_state state)</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">	 * This #ifdef needs to die, but it&#x27;s too late in the cycle to</span><br><span class="line">	 * make this generic (arm and sh have never invoked the canary</span><br><span class="line">	 * init for the non boot cpus!). Will be fixed in 3.11</span><br><span class="line">	 */</span><br><span class="line">	 </span><br><span class="line">	 </span><br><span class="line">	 /*</span><br><span class="line">	  * 1.C语言中#ifdef和#else、#endif是条件编译语句，也就是说在满足某些条件的时候，</span><br><span class="line">	  * 夹在这几个关键字中间的代码才编译，不满足就不编译</span><br><span class="line">	  * 2.下面这句话的意思就是如果定义了CONFIG_X86这个宏，就把boot_init_stack_canary这个代码编译进去</span><br><span class="line">	  */</span><br><span class="line">#ifdef CONFIG_X86</span><br><span class="line">	/*</span><br><span class="line">	 * If we&#x27;re the non-boot CPU, nothing set the stack canary up</span><br><span class="line">	 * for us. The boot CPU already has it initialized but no harm</span><br><span class="line">	 * in doing it again. This is a good place for updating it, as</span><br><span class="line">	 * we wont ever return from this function (so the invalid</span><br><span class="line">	 * canaries already on the stack wont ever trigger).</span><br><span class="line">	 */</span><br><span class="line">	boot_init_stack_canary();//只有在x86这种non-boot CPU机器上执行，该函数主要用于初始化stack_canary的值,用于防止栈溢出</span><br><span class="line">#endif</span><br><span class="line">	__current_set_polling(); //设置本架构下面有标示轮询poll的bit位，保证cpu进行重新调度。</span><br><span class="line">	arch_cpu_idle_prepare(); //进行idle前的准备工作，ARM64中没有实现</span><br><span class="line">	per_cpu(idle_force_poll, smp_processor_id()) = 0;</span><br><span class="line">	cpu_idle_loop(); //进入idle进程的事件循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-13-cpu-idle-loop"><a href="#1-13-cpu-idle-loop" class="headerlink" title="1.13 cpu_idle_loop"></a>1.13 cpu_idle_loop</h3><p>定义在msm&#x2F;kernel&#x2F;cpu&#x2F;idle.c中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Generic idle loop implementation</span><br><span class="line"> */</span><br><span class="line">static void cpu_idle_loop(void)</span><br><span class="line">&#123;</span><br><span class="line">	while (1) &#123; //开启无限循环，进行进程调度</span><br><span class="line">		tick_nohz_idle_enter(); //停止周期时钟</span><br><span class="line"></span><br><span class="line">		while (!need_resched()) &#123; //判断是否有设置TIF_NEED_RESCHED，只有系统没有进程需要调度时才执行while里面操作</span><br><span class="line">			check_pgt_cache();</span><br><span class="line">			rmb();</span><br><span class="line"></span><br><span class="line">			local_irq_disable(); //关闭irq中断</span><br><span class="line">			arch_cpu_idle_enter();</span><br><span class="line"></span><br><span class="line">			/*</span><br><span class="line">			 * In poll mode we reenable interrupts and spin.</span><br><span class="line">			 *</span><br><span class="line">			 * Also if we detected in the wakeup from idle</span><br><span class="line">			 * path that the tick broadcast device expired</span><br><span class="line">			 * for us, we don&#x27;t want to go deep idle as we</span><br><span class="line">			 * know that the IPI is going to arrive right</span><br><span class="line">			 * away</span><br><span class="line">			 */</span><br><span class="line">			if (cpu_idle_force_poll ||</span><br><span class="line">			    tick_check_broadcast_expired() ||</span><br><span class="line">			    __get_cpu_var(idle_force_poll)) &#123;</span><br><span class="line">				cpu_idle_poll(); //进入 CPU 的poll mode模式，避免进入深度睡眠，可以处理 处理器间中断</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				if (!current_clr_polling_and_test()) &#123;</span><br><span class="line">					stop_critical_timings();</span><br><span class="line">					rcu_idle_enter();</span><br><span class="line">					arch_cpu_idle(); //进入 CPU 的 idle 模式，省电</span><br><span class="line">					WARN_ON_ONCE(irqs_disabled());</span><br><span class="line">					rcu_idle_exit();</span><br><span class="line">					start_critical_timings();</span><br><span class="line">				&#125; else &#123;</span><br><span class="line">					local_irq_enable();</span><br><span class="line">				&#125;</span><br><span class="line">				__current_set_polling();</span><br><span class="line">			&#125;</span><br><span class="line">			arch_cpu_idle_exit();</span><br><span class="line">		&#125;</span><br><span class="line">		tick_nohz_idle_exit(); //如果有进程需要调度，则先开启周期时钟</span><br><span class="line">		schedule_preempt_disabled(); //让出cpu，执行调度</span><br><span class="line">		if (cpu_is_offline(smp_processor_id())) //如果当前cpu处理offline状态，关闭idle进程</span><br><span class="line">			arch_cpu_idle_dead();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>idle进程并不执行什么复杂的工作，只有在系统没有其他进程调度的时候才进入idle进程，而在idle进程中尽可能让cpu空闲下来，连周期时钟也关掉了，达到省电目的。当有其他进程需要调度的时候，马上开启周期时钟，然后让出cpu。</p>
<p><strong>小结</strong></p>
<p>idle进程是Linux系统的第一个进程，进程号是0，在完成系统环境初始化工作之后，开启了两个重要的进程，init进程和kthreadd进程，执行完创建工作之后，开启一个无限循环，负责进程的调度。</p>
<h2 id="二、kthreadd进程启动"><a href="#二、kthreadd进程启动" class="headerlink" title="二、kthreadd进程启动"></a>二、kthreadd进程启动</h2><p>之前在rest_init函数中启动了kthreadd进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);</span><br></pre></td></tr></table></figure>
<p>进程创建成功后会执行kthreadd函数</p>
<h3 id="2-1-kthreadd"><a href="#2-1-kthreadd" class="headerlink" title="2.1 kthreadd"></a>2.1 kthreadd</h3><p>定义在msm&#x2F;kernel&#x2F;kthread.c中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">int kthreadd(void *unused)</span><br><span class="line">&#123;</span><br><span class="line">	struct task_struct *tsk = current;</span><br><span class="line"></span><br><span class="line">	/* Setup a clean context for our children to inherit. */</span><br><span class="line">	set_task_comm(tsk, &quot;kthreadd&quot;);</span><br><span class="line">	ignore_signals(tsk);</span><br><span class="line">	set_cpus_allowed_ptr(tsk, cpu_all_mask); //  允许kthreadd在任意CPU上运行</span><br><span class="line">	set_mems_allowed(node_states[N_MEMORY]);</span><br><span class="line"></span><br><span class="line">	current-&gt;flags |= PF_NOFREEZE;</span><br><span class="line"></span><br><span class="line">	for (;;) &#123;</span><br><span class="line">		set_current_state(TASK_INTERRUPTIBLE); //首先将线程状态设置为 TASK_INTERRUPTIBLE,</span><br><span class="line">		//如果当前没有要创建的线程则主动放弃 CPU 完成调度.此进程变为阻塞态</span><br><span class="line"></span><br><span class="line">		if (list_empty(&amp;kthread_create_list)) //  没有需要创建的内核线程</span><br><span class="line">			schedule(); //   执行一次调度, 让出CPU</span><br><span class="line">		__set_current_state(TASK_RUNNING);//  运行到此表示 kthreadd 线程被唤醒(就是我们当前),设置进程运行状态为 TASK_RUNNING</span><br><span class="line">		spin_lock(&amp;kthread_create_lock); //spin_lock和spin_unlock是配套的加锁机制，spin_lock是加锁</span><br><span class="line">		while (!list_empty(&amp;kthread_create_list)) &#123;</span><br><span class="line">			struct kthread_create_info *create;</span><br><span class="line"></span><br><span class="line">			create = list_entry(kthread_create_list.next,</span><br><span class="line">					    struct kthread_create_info, list); //kthread_create_list是一个链表，</span><br><span class="line">					    //从链表中取出下一个要创建的kthread_create_info,即线程创建信息</span><br><span class="line"></span><br><span class="line">			list_del_init(&amp;create-&gt;list); //删除create中的list</span><br><span class="line">			spin_unlock(&amp;kthread_create_lock); //解锁</span><br><span class="line"></span><br><span class="line">			create_kthread(create); //创建线程</span><br><span class="line"></span><br><span class="line">			spin_lock(&amp;kthread_create_lock); </span><br><span class="line">		&#125;</span><br><span class="line">		spin_unlock(&amp;kthread_create_lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kthreadd函数的作用就是循环地从kthread_create_list链表中取出要创建的线程，然后执行create_kthread函数，直到kthread_create_list为空，让出CPU,进入睡眠，我们来看下create_kthread函数</p>
<h3 id="2-2-create-kthread"><a href="#2-2-create-kthread" class="headerlink" title="2.2 create_kthread"></a>2.2 create_kthread</h3><p>定义在msm&#x2F;kernel&#x2F;kthread.c中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static void create_kthread(struct kthread_create_info *create)</span><br><span class="line">&#123;</span><br><span class="line">	int pid;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_NUMA</span><br><span class="line">	current-&gt;pref_node_fork = create-&gt;node;</span><br><span class="line">#endif</span><br><span class="line">	/* We want our own signal handler (we take no signals by default). */</span><br><span class="line">	pid = kernel_thread(kthread, create, CLONE_FS | CLONE_FILES | SIGCHLD);</span><br><span class="line">	if (pid &lt; 0) &#123;</span><br><span class="line">		create-&gt;result = ERR_PTR(pid);</span><br><span class="line">		complete(&amp;create-&gt;done);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这里面就是调用kernel_thread函数创建进程，然后执行kthread函数，注意不要搞混了，之前那个函数叫kthreadd，接下来看看kthread函数</p>
<h3 id="2-3-kthread"><a href="#2-3-kthread" class="headerlink" title="2.3 kthread"></a>2.3 kthread</h3><p>定义在msm&#x2F;kernel&#x2F;kthread.c中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static int kthread(void *_create)</span><br><span class="line">&#123;</span><br><span class="line">	/* Copy data: it&#x27;s on kthread&#x27;s stack */</span><br><span class="line">	struct kthread_create_info *create = _create;  // create 就是之前kthreadd函数循环取出的 kthread_create_info</span><br><span class="line">	int (*threadfn)(void *data) = create-&gt;threadfn; //新线程工作函数</span><br><span class="line">	void *data = create-&gt;data;</span><br><span class="line">	struct kthread self;</span><br><span class="line">	int ret;</span><br><span class="line"></span><br><span class="line">	self.flags = 0;</span><br><span class="line">	self.data = data;</span><br><span class="line">	init_completion(&amp;self.exited);</span><br><span class="line">	init_completion(&amp;self.parked);</span><br><span class="line">	current-&gt;vfork_done = &amp;self.exited;</span><br><span class="line"></span><br><span class="line">	/* OK, tell user we&#x27;re spawned, wait for stop or wakeup */</span><br><span class="line">	__set_current_state(TASK_UNINTERRUPTIBLE);</span><br><span class="line">	create-&gt;result = current;</span><br><span class="line">	complete(&amp;create-&gt;done); //表示线程创建完毕</span><br><span class="line">	schedule(); //让出CPU，注意这里并没有执行新线程的threadfn函数就直接进入睡眠了，然后等待线程被手动唤醒，然后才执行threadfn</span><br><span class="line"></span><br><span class="line">	ret = -EINTR;</span><br><span class="line"></span><br><span class="line">	if (!test_bit(KTHREAD_SHOULD_STOP, &amp;self.flags)) &#123;</span><br><span class="line">		__kthread_parkme(&amp;self);</span><br><span class="line">		ret = threadfn(data);</span><br><span class="line">	&#125;</span><br><span class="line">	/* we can&#x27;t just return, we must preserve &quot;self&quot; on stack */</span><br><span class="line">	do_exit(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-kthread-create-amp-kthread-run"><a href="#2-4-kthread-create-amp-kthread-run" class="headerlink" title="2.4 kthread_create &amp; kthread_run"></a>2.4 kthread_create &amp; kthread_run</h3><p>定义在msm&#x2F;include&#x2F;linux&#x2F;kthread.h</p>
<p>kthreadd创建线程是遍历kthread_create_list列表，那kthread_create_list列表中的值是哪儿来的呢？我们知道Linux创建内核线程有两种方式，kthread_create和kthread_run</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define kthread_create(threadfn, data, namefmt, arg...) \</span><br><span class="line">	kthread_create_on_node(threadfn, data, -1, namefmt, ##arg)</span><br><span class="line"></span><br><span class="line">#define kthread_run(threadfn, data, namefmt, ...)			   \</span><br><span class="line">(&#123;									   \</span><br><span class="line">	struct task_struct *__k						   \</span><br><span class="line">		= kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \</span><br><span class="line">	if (!IS_ERR(__k))						   \</span><br><span class="line">		wake_up_process(__k);	//手动唤醒新线程				   \</span><br><span class="line">	__k;								   \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>kthread_create和kthread_run并不是函数，而是宏，宏相当于Java中的final static定义，在编译时会替换对应代码，宏的参数没有类型定义，多行宏的定义会在行末尾加上\</p>
<p>这两个宏最终都是调用kthread_create_on_node函数，只是kthread_run在线程创建完成后会手动唤醒，我们来看看kthread_create_on_node函数</p>
<h3 id="2-5-kthread-create-on-node"><a href="#2-5-kthread-create-on-node" class="headerlink" title="2.5 kthread_create_on_node"></a>2.5 kthread_create_on_node</h3><p>定义在msm&#x2F;kernel&#x2F;kthread.c中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * kthread_create_on_node - create a kthread.</span><br><span class="line"> * @threadfn: the function to run until signal_pending(current).</span><br><span class="line"> * @data: data ptr for @threadfn.</span><br><span class="line"> * @node: memory node number.</span><br><span class="line"> * @namefmt: printf-style name for the thread.</span><br><span class="line"> *</span><br><span class="line"> * Description: This helper function creates and names a kernel</span><br><span class="line"> * thread.  The thread will be stopped: use wake_up_process() to start</span><br><span class="line"> * it.  See also kthread_run().</span><br><span class="line"> *</span><br><span class="line"> * If thread is going to be bound on a particular cpu, give its node</span><br><span class="line"> * in @node, to get NUMA affinity for kthread stack, or else give -1.</span><br><span class="line"> * When woken, the thread will run @threadfn() with @data as its</span><br><span class="line"> * argument. @threadfn() can either call do_exit() directly if it is a</span><br><span class="line"> * standalone thread for which no one will call kthread_stop(), or</span><br><span class="line"> * return when &#x27;kthread_should_stop()&#x27; is true (which means</span><br><span class="line"> * kthread_stop() has been called).  The return value should be zero</span><br><span class="line"> * or a negative error number; it will be passed to kthread_stop().</span><br><span class="line"> *</span><br><span class="line"> * Returns a task_struct or ERR_PTR(-ENOMEM).</span><br><span class="line"> */</span><br><span class="line">struct task_struct *kthread_create_on_node(int (*threadfn)(void *data),</span><br><span class="line">					   void *data, int node,</span><br><span class="line">					   const char namefmt[],</span><br><span class="line">					   ...)</span><br><span class="line">&#123;</span><br><span class="line">	struct kthread_create_info create;</span><br><span class="line"></span><br><span class="line">	create.threadfn = threadfn;</span><br><span class="line">	create.data = data;</span><br><span class="line">	create.node = node;</span><br><span class="line">	init_completion(&amp;create.done);  //初始化&amp;create.done，之前讲过completion和wait_for_completion同步</span><br><span class="line"></span><br><span class="line">	spin_lock(&amp;kthread_create_lock);  //加锁，之前也讲过</span><br><span class="line">	list_add_tail(&amp;create.list, &amp;kthread_create_list);  //将要创建的线程加到kthread_create_list链表尾部</span><br><span class="line">	spin_unlock(&amp;kthread_create_lock);</span><br><span class="line"></span><br><span class="line">	wake_up_process(kthreadd_task);  //唤醒kthreadd进程，开启列表循环创建线程</span><br><span class="line">	wait_for_completion(&amp;create.done);  //当&amp;create.done complete时，会继续往下执行</span><br><span class="line"></span><br><span class="line">	if (!IS_ERR(create.result)) &#123;</span><br><span class="line">		static const struct sched_param param = &#123; .sched_priority = 0 &#125;;</span><br><span class="line">		va_list args;  //不定参数定义，相当于Java中的... ，定义多个数量不定的参数</span><br><span class="line"></span><br><span class="line">		va_start(args, namefmt);</span><br><span class="line">		vsnprintf(create.result-&gt;comm, sizeof(create.result-&gt;comm),</span><br><span class="line">			  namefmt, args);</span><br><span class="line">		va_end(args);</span><br><span class="line">		/*</span><br><span class="line">		 * root may have changed our (kthreadd&#x27;s) priority or CPU mask.</span><br><span class="line">		 * The kernel thread should not inherit these properties.</span><br><span class="line">		 */</span><br><span class="line">		sched_setscheduler_nocheck(create.result, SCHED_NORMAL, &amp;param);  //create.result类型为task_struct，</span><br><span class="line">		//该函数作用是设置新线程调度策略，SCHED_NORMAL 普通调度策略，非实时，</span><br><span class="line">		//优先级低于实时调度策略SCHED_FIFO和SCHED_RR，param的优先级上面定义为0</span><br><span class="line"></span><br><span class="line">		set_cpus_allowed_ptr(create.result, cpu_all_mask); //允许新线程在任意CPU上运行</span><br><span class="line">	&#125;</span><br><span class="line">	return create.result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kthread_create_on_node主要作用就是在kthread_create_list链表尾部加上要创建的线程，然后唤醒kthreadd进程进行具体创建工作</p>
<p><strong>小结</strong></p>
<p>kthreadd进程由idle通过kernel_thread创建，并始终运行在内核空间, 负责所有内核线程的调度和管理，所有的内核线程都是直接或者间接的以kthreadd为父进程。</p>
<ul>
<li>kthreadd进程会执行一个kthreadd的函数，该函数的作用就是遍历kthread_create_list链表，从链表中取出需要创建的内核线程进行创建, 创建成功后会执行kthread函数。</li>
<li>kthread函数完成一些初始赋值后就让出CPU，并没有执行新线程的工作函数，因此需要手工 wake up被唤醒后，新线程才执行自己的真正工作函数。</li>
<li>当我们调用kthread_create和kthread_run创建的内核线程会被加入到kthread_create_list链表，kthread_create不会手动wake up新线程，kthread_run会手动wake up新线程。</li>
</ul>
<p>其实这就是一个典型的生产者消费者模式，kthread_create和kthread_run负责生产各种内核线程创建需求，kthreadd开启循环去消费各种内核线程创建需求。</p>
<h2 id="三、init进程启动"><a href="#三、init进程启动" class="headerlink" title="三、init进程启动"></a>三、init进程启动</h2><p>init进程分为前后两部分，前一部分是在内核启动的，主要是完成创建和内核初始化工作，内容都是跟Linux内核相关的;后一部分是在用户空间启动的，主要完成Android系统的初始化工作。</p>
<p>我这里要讲的是前一部分，后一部分将在下一篇文章中讲述。</p>
<p>之前在rest_init函数中启动了init进程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel_thread(kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);</span><br></pre></td></tr></table></figure>
<p>在创建完init进程后，会调用kernel_init函数</p>
<h3 id="3-1-kernel-init"><a href="#3-1-kernel-init" class="headerlink" title="3.1 kernel_init"></a>3.1 kernel_init</h3><p>定义在msm&#x2F;init&#x2F;main.c中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * __ref 这个跟之前讲的__init作用一样</span><br><span class="line"> */</span><br><span class="line">static int __ref kernel_init(void *unused)</span><br><span class="line">&#123;</span><br><span class="line">	kernel_init_freeable(); //进行init进程的一些初始化操作</span><br><span class="line">	/* need to finish all async __init code before freeing the memory */</span><br><span class="line">	async_synchronize_full();// 等待所有异步调用执行完成,，在释放内存前，必须完成所有的异步 __init 代码</span><br><span class="line">	free_initmem();// 释放所有init.* 段中的内存</span><br><span class="line">	mark_rodata_ro(); //arm64空实现</span><br><span class="line">	system_state = SYSTEM_RUNNING;// 设置系统状态为运行状态</span><br><span class="line">	numa_default_policy(); // 设定NUMA系统的默认内存访问策略</span><br><span class="line"></span><br><span class="line">	flush_delayed_fput(); // 释放所有延时的struct file结构体</span><br><span class="line"></span><br><span class="line">	if (ramdisk_execute_command) &#123; //ramdisk_execute_command的值为&quot;/init&quot;</span><br><span class="line">		if (!run_init_process(ramdisk_execute_command)) //运行根目录下的init程序</span><br><span class="line">			return 0;</span><br><span class="line">		pr_err(&quot;Failed to execute %s\n&quot;, ramdisk_execute_command);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * We try each of these until one succeeds.</span><br><span class="line">	 *</span><br><span class="line">	 * The Bourne shell can be used instead of init if we are</span><br><span class="line">	 * trying to recover a really broken machine.</span><br><span class="line">	 */</span><br><span class="line">	if (execute_command) &#123; //execute_command的值如果有定义就去根目录下找对应的应用程序,然后启动</span><br><span class="line">		if (!run_init_process(execute_command))</span><br><span class="line">			return 0;</span><br><span class="line">		pr_err(&quot;Failed to execute %s.  Attempting defaults...\n&quot;,</span><br><span class="line">			execute_command);</span><br><span class="line">	&#125;</span><br><span class="line">	if (!run_init_process(&quot;/sbin/init&quot;) || //如果ramdisk_execute_command和execute_command定义的应用程序都没有找到，</span><br><span class="line">	//就到根目录下找 /sbin/init，/etc/init，/bin/init,/bin/sh 这四个应用程序进行启动</span><br><span class="line"></span><br><span class="line">	    !run_init_process(&quot;/etc/init&quot;) ||</span><br><span class="line">	    !run_init_process(&quot;/bin/init&quot;) ||</span><br><span class="line">	    !run_init_process(&quot;/bin/sh&quot;))</span><br><span class="line">		return 0;</span><br><span class="line"></span><br><span class="line">	panic(&quot;No init found.  Try passing init= option to kernel. &quot;</span><br><span class="line">	      &quot;See Linux Documentation/init.txt for guidance.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kernel_init主要工作是完成一些init的初始化操作，然后去系统根目录下依次找ramdisk_execute_command和execute_command设置的应用程序，如果这两个目录都找不到，就依次去根目录下找 &#x2F;sbin&#x2F;init，&#x2F;etc&#x2F;init，&#x2F;bin&#x2F;init,&#x2F;bin&#x2F;sh 这四个应用程序进行启动，只要这些应用程序有一个启动了，其他就不启动了</p>
<p>ramdisk_execute_command和execute_command的值是通过bootloader传递过来的参数设置的，ramdisk_execute_command通过”rdinit”参数赋值，execute_command通过”init”参数赋值</p>
<p>ramdisk_execute_command如果没有被赋值，kernel_init_freeable函数会赋一个初始值”&#x2F;init”</p>
<h3 id="3-2-kernel-init-freeable"><a href="#3-2-kernel-init-freeable" class="headerlink" title="3.2 kernel_init_freeable"></a>3.2 kernel_init_freeable</h3><p>定义在msm&#x2F;init&#x2F;main.c中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">static noinline void __init kernel_init_freeable(void)</span><br><span class="line">&#123;</span><br><span class="line">	/*</span><br><span class="line">	 * Wait until kthreadd is all set-up.</span><br><span class="line">	 */</span><br><span class="line">	wait_for_completion(&amp;kthreadd_done); //等待&amp;kthreadd_done这个值complete,这个在rest_init方法中有写，在ktreadd进程启动完成后设置为complete</span><br><span class="line"></span><br><span class="line">	/* Now the scheduler is fully set up and can do blocking allocations */</span><br><span class="line">	gfp_allowed_mask = __GFP_BITS_MASK;//设置bitmask, 使得init进程可以使用PM并且允许I/O阻塞操作</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * init can allocate pages on any node</span><br><span class="line">	 */</span><br><span class="line">	set_mems_allowed(node_states[N_MEMORY]);//init进程可以分配物理页面</span><br><span class="line">	/*</span><br><span class="line">	 * init can run on any cpu.</span><br><span class="line">	 */</span><br><span class="line">	set_cpus_allowed_ptr(current, cpu_all_mask); //init进程可以在任意cpu上执行</span><br><span class="line"></span><br><span class="line">	cad_pid = task_pid(current); //设置到init进程的pid号给cad_pid，cad就是ctrl-alt-del，设置init进程来处理ctrl-alt-del信号</span><br><span class="line"></span><br><span class="line">	smp_prepare_cpus(setup_max_cpus);//设置smp初始化时的最大CPU数量，然后将对应数量的CPU状态设置为present</span><br><span class="line"></span><br><span class="line">	do_pre_smp_initcalls();//调用__initcall_start到__initcall0_start之间的initcall_t函数指针</span><br><span class="line">	lockup_detector_init(); //开启watchdog_threads，watchdog主要用来监控、管理CPU的运行状态</span><br><span class="line"></span><br><span class="line">	smp_init();//启动cpu0外的其他cpu核</span><br><span class="line">	sched_init_smp(); //进程调度域初始化</span><br><span class="line"></span><br><span class="line">	do_basic_setup();//初始化设备，驱动等，这个方法比较重要，将在下面单独讲</span><br><span class="line"></span><br><span class="line">	/* Open the /dev/console on the rootfs, this should never fail */</span><br><span class="line">	if (sys_open((const char __user *) &quot;/dev/console&quot;, O_RDWR, 0) &lt; 0) // 打开/dev/console，</span><br><span class="line">	//文件号0，作为init进程标准输入</span><br><span class="line"></span><br><span class="line">		pr_err(&quot;Warning: unable to open an initial console.\n&quot;);</span><br><span class="line"></span><br><span class="line">	(void) sys_dup(0);// 标准输入</span><br><span class="line">	(void) sys_dup(0);// 标准输出</span><br><span class="line">	/*</span><br><span class="line">	 * check if there is an early userspace init.  If yes, let it do all</span><br><span class="line">	 * the work</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	if (!ramdisk_execute_command)  //如果 ramdisk_execute_command 没有赋值，则赋值为&quot;/init&quot;，之前有讲到</span><br><span class="line">		ramdisk_execute_command = &quot;/init&quot;;</span><br><span class="line"></span><br><span class="line">	if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) &#123;</span><br><span class="line">	// 尝试进入ramdisk_execute_command指向的文件，如果失败则重新挂载根文件系统</span><br><span class="line"></span><br><span class="line">		ramdisk_execute_command = NULL;</span><br><span class="line">		prepare_namespace();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/*</span><br><span class="line">	 * Ok, we have completed the initial bootup, and</span><br><span class="line">	 * we&#x27;re essentially up and running. Get rid of the</span><br><span class="line">	 * initmem segments and start the user-mode stuff..</span><br><span class="line">	 */</span><br><span class="line"></span><br><span class="line">	/* rootfs is available now, try loading default modules */</span><br><span class="line">	load_default_modules(); // 加载I/O调度的电梯算法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kernel_init_freeable函数做了很多重要的事情</p>
<ul>
<li>启动了smp，smp全称是Symmetrical Multi-Processing，即对称多处理，是指在一个计算机上汇集了一组处理器(多CPU),各CPU之间共享内存子系统以及总线结构。</li>
<li>初始化设备和驱动程序</li>
<li>打开标准输入和输出</li>
<li>初始化文件系统</li>
</ul>
<h3 id="3-3-do-basic-setup"><a href="#3-3-do-basic-setup" class="headerlink" title="3.3 do_basic_setup"></a>3.3 do_basic_setup</h3><p>定义在msm&#x2F;init&#x2F;main.c中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Ok, the machine is now initialized. None of the devices</span><br><span class="line"> * have been touched yet, but the CPU subsystem is up and</span><br><span class="line"> * running, and memory and process management works.</span><br><span class="line"> *</span><br><span class="line"> * Now we can finally start doing some real work..</span><br><span class="line"> */</span><br><span class="line">static void __init do_basic_setup(void)</span><br><span class="line">&#123;</span><br><span class="line">	cpuset_init_smp();//针对SMP系统，初始化内核control group的cpuset子系统。</span><br><span class="line">	usermodehelper_init();// 创建khelper单线程工作队列，用于协助新建和运行用户空间程序</span><br><span class="line">	shmem_init();// 初始化共享内存</span><br><span class="line">	driver_init();// 初始化设备驱动，比较重要下面单独讲</span><br><span class="line">	init_irq_proc();//创建/proc/irq目录, 并初始化系统中所有中断对应的子目录</span><br><span class="line">	do_ctors();// 执行内核的构造函数</span><br><span class="line">	usermodehelper_enable();// 启用usermodehelper</span><br><span class="line">	do_initcalls();//遍历initcall_levels数组，调用里面的initcall函数，这里主要是对设备、驱动、文件系统进行初始化，</span><br><span class="line">	//之所有将函数封装到数组进行遍历，主要是为了好扩展</span><br><span class="line"></span><br><span class="line">	random_int_secret_init();//初始化随机数生成池</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-driver-init"><a href="#3-4-driver-init" class="headerlink" title="3.4 driver_init"></a>3.4 driver_init</h3><p>定义在msm&#x2F;drivers&#x2F;base&#x2F;init.c中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * driver_init - initialize driver model.</span><br><span class="line"> *</span><br><span class="line"> * Call the driver model init functions to initialize their</span><br><span class="line"> * subsystems. Called early from init/main.c.</span><br><span class="line"> */</span><br><span class="line">void __init driver_init(void)</span><br><span class="line">&#123;</span><br><span class="line">	/* These are the core pieces */</span><br><span class="line">	devtmpfs_init();// 注册devtmpfs文件系统，启动kdevtmpfs进程</span><br><span class="line">	devices_init();// 初始化驱动模型中的部分子系统，kset：devices 和 kobject：dev、 dev/block、 dev/char</span><br><span class="line">	buses_init();// 初始化驱动模型中的bus子系统，kset：bus、devices/system</span><br><span class="line">	classes_init();// 初始化驱动模型中的class子系统，kset：class</span><br><span class="line">	firmware_init();// 初始化驱动模型中的firmware子系统 ，kobject：firmware</span><br><span class="line">	hypervisor_init();// 初始化驱动模型中的hypervisor子系统，kobject：hypervisor</span><br><span class="line"></span><br><span class="line">	/* These are also core pieces, but must come after the</span><br><span class="line">	 * core core pieces.</span><br><span class="line">	 */</span><br><span class="line">	platform_bus_init();// 初始化驱动模型中的bus/platform子系统,这个节点是所有platform设备和驱动的总线类型，</span><br><span class="line">	//即所有platform设备和驱动都会挂载到这个总线上</span><br><span class="line"></span><br><span class="line">	cpu_dev_init(); // 初始化驱动模型中的devices/system/cpu子系统,该节点包含CPU相关的属性</span><br><span class="line">	memory_dev_init();//初始化驱动模型中的/devices/system/memory子系统,该节点包含了内存相关的属性，如块大小等</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数完成驱动子系统的构建，实现了Linux设备驱动的一个整体框架，但是它只是建立了目录结构，具体驱动的装载是在do_initcalls函数，之前有讲</p>
<p>kernel_init_freeable函数告一段落了，我们接着讲kernel_init中剩余的函数</p>
<h3 id="3-5-free-initmem"><a href="#3-5-free-initmem" class="headerlink" title="3.5 free_initmem"></a>3.5 free_initmem</h3><p>定义在msm&#x2F;arch&#x2F;arm64&#x2F;mm&#x2F;init.c中中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void free_initmem(void)</span><br><span class="line">&#123;</span><br><span class="line">	poison_init_mem(__init_begin, __init_end - __init_begin);</span><br><span class="line">	free_initmem_default(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有使用__init标记过的函数和使用__initdata标记过的数据，在free_initmem函数执行后，都不能使用，它们曾经获得的内存现在可以重新用于其他目的。</p>
<h3 id="3-6-flush-delayed-fput"><a href="#3-6-flush-delayed-fput" class="headerlink" title="3.6 flush_delayed_fput"></a>3.6 flush_delayed_fput</h3><p>定义在msm&#x2F;arch&#x2F;arm64&#x2F;mm&#x2F;init.c中,它执行的是delayed_fput(NULL)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static void delayed_fput(struct work_struct *unused)</span><br><span class="line">&#123;</span><br><span class="line">	LIST_HEAD(head);</span><br><span class="line">	spin_lock_irq(&amp;delayed_fput_lock);</span><br><span class="line">	list_splice_init(&amp;delayed_fput_list, &amp;head);</span><br><span class="line">	spin_unlock_irq(&amp;delayed_fput_lock);</span><br><span class="line">	while (!list_empty(&amp;head)) &#123;</span><br><span class="line">		struct file *f = list_first_entry(&amp;head, struct file, f_u.fu_list);</span><br><span class="line">		list_del_init(&amp;f-&gt;f_u.fu_list); //删除fu_list</span><br><span class="line">		__fput(f); //释放struct file</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数主要用于释放&amp;delayed_fput_list这个链表中的struct file，struct file即文件结构体，代表一个打开的文件，系统中的每个打开的文件在内核空间都有一个关联的 struct file。</p>
<h3 id="3-7-run-init-process"><a href="#3-7-run-init-process" class="headerlink" title="3.7 run_init_process"></a>3.7 run_init_process</h3><p>定义在msm&#x2F;init&#x2F;main.c中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static int run_init_process(const char *init_filename)</span><br><span class="line">&#123;</span><br><span class="line">	argv_init[0] = init_filename;</span><br><span class="line">	return do_execve(init_filename,</span><br><span class="line">		(const char __user *const __user *)argv_init,</span><br><span class="line">		(const char __user *const __user *)envp_init); //do_execve就是执行一个可执行文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>run_init_process就是运行可执行文件了，从kernel_init函数中可知，系统会依次去找根目录下的init，execute_command，&#x2F;sbin&#x2F;init，&#x2F;etc&#x2F;init，&#x2F;bin&#x2F;init,&#x2F;bin&#x2F;sh这六个可执行文件，只要找到其中一个，其他就不执行。</p>
<p>Android系统一般会在根目录下放一个init的可执行文件，也就是说Linux系统的init进程在内核初始化完成后，就直接执行init这个文件，这个文件的源代码在platform&#x2F;system&#x2F;core&#x2F;init&#x2F;init.cpp，下一篇文章中我将从这个文件为入口，讲解Android系统的init进程。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/foxleezh">foxleezh</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://github.com/foxleezh/AOSP/issues/3">https://github.com/foxleezh/AOSP/issues/3</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">©著作权归作者所有，如需转载，请联系作者获取转载授权，否则将追究法律责任</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Android/">Android</a></div><div class="post_share"><div class="social-share" data-image="/imgs/202202/6a46ae1ab70f1a5c15a863a5372e694a_MD5.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/imgs/wechat.png" target="_blank"><img class="post-qr-code-img" src="/imgs/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/imgs/alipay.png" target="_blank"><img class="post-qr-code-img" src="/imgs/alipay.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/202203/%E9%80%9A%E8%BF%87nvm%E5%AE%89%E8%A3%85Node.js.html" title="通过nvm安装Node.js"><img class="cover" src="/imgs/c2.jpg" onerror="onerror=null;src='/imgs/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">通过nvm安装Node.js</div></div></a></div><div class="next-post pull-right"><a href="/202202/android/foxleezh-%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BBAndroid%E6%BA%90%E7%A0%81.html" title="如何阅读Android源码"><img class="cover" src="/imgs/202202/c4d51f0ce1188c6f04d71a7a9c854905_MD5.png" onerror="onerror=null;src='/imgs/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">如何阅读Android源码</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/202212/android/Android%20Framework%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95-Java%E9%83%A8%E5%88%86.html" title="Android Framework调试方法-Java部分"><img class="cover" src="/imgs/c5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-18</div><div class="title">Android Framework调试方法-Java部分</div></div></a></div><div><a href="/202212/android/AOSP%E7%B3%BB%E7%BB%9F%E9%80%9A%E7%9F%A5Notification.html" title="AOSP系统通知Notification"><img class="cover" src="/imgs/c5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-22</div><div class="title">AOSP系统通知Notification</div></div></a></div><div><a href="/202303/android/Android%20Makefile%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E.html" title="Android Makefile中常用函数说明"><img class="cover" src="/imgs/c0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-10</div><div class="title">Android Makefile中常用函数说明</div></div></a></div><div><a href="/202303/android/Android%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3.html" title="Android存储相关"><img class="cover" src="/imgs/c3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-11</div><div class="title">Android存储相关</div></div></a></div><div><a href="/202212/android/AOSP%E9%95%BF%E6%8C%89%E5%85%B3%E6%9C%BA%E9%94%AE%E7%9B%B4%E6%8E%A5%E5%85%B3%E6%9C%BA%E9%80%BB%E8%BE%91.html" title="AOSP长按关机键直接关机逻辑"><img class="cover" src="/imgs/c0.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-18</div><div class="title">AOSP长按关机键直接关机逻辑</div></div></a></div><div><a href="/202204/android/Android%E7%B3%BB%E7%BB%9FLauncher%E4%B8%8A%E6%89%8B.html" title="Android系统Launcher上手"><img class="cover" src="/imgs/c4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-20</div><div class="title">Android系统Launcher上手</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/imgs/avatar.jpg" onerror="this.onerror=null;this.src='/imgs/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">赖兴兵</div><div class="author-info__description">这个网站是我个人博客站点，分享一些自己平时工作生活中遇到或者学习的内容，内容包含Java后端技术体系，Android前端技术体系，软件工程师成长等等。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">32</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jonathanlai"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/jonathanlai" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://twitter.com/JonnyLai85" target="_blank" title="Twitter"><i class="fa-brands fa-twitter"></i></a><a class="social-icon" href="https://facebook.com/jonathan.lai.1426" target="_blank" title="Facebook"><i class="fa-brands fa-facebook"></i></a><a class="social-icon" href="https://instagram.com/jonathanlai8511/" target="_blank" title="Instagram"><i class="fa-brands fa-square-instagram"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">放弃几年的Blog重新开始写了 ~:></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81idle%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8"><span class="toc-number">2.</span> <span class="toc-text">一、idle进程启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-rest-init"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 rest_init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-rcu-scheduler-starting"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 rcu_scheduler_starting</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-kernel-thread"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 kernel_thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-kernel-init"><span class="toc-number">2.4.</span> <span class="toc-text">1.4 kernel_init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-numa-default-policy"><span class="toc-number">2.5.</span> <span class="toc-text">1.5 numa_default_policy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-kthreadd"><span class="toc-number">2.6.</span> <span class="toc-text">1.6 kthreadd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-rcu-read-lock-amp-rcu-read-unlock"><span class="toc-number">2.7.</span> <span class="toc-text">1.7 rcu_read_lock &amp; rcu_read_unlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-find-task-by-pid-ns"><span class="toc-number">2.8.</span> <span class="toc-text">1.8 find_task_by_pid_ns</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-9-sched-setscheduler-nocheck"><span class="toc-number">2.9.</span> <span class="toc-text">1.9 sched_setscheduler_nocheck</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-10-init-idle-bootup-task"><span class="toc-number">2.10.</span> <span class="toc-text">1.10 init_idle_bootup_task</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-11-schedule-preempt-disabled"><span class="toc-number">2.11.</span> <span class="toc-text">1.11 schedule_preempt_disabled</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-12-cpu-startup-entry"><span class="toc-number">2.12.</span> <span class="toc-text">1.12 cpu_startup_entry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-13-cpu-idle-loop"><span class="toc-number">2.13.</span> <span class="toc-text">1.13 cpu_idle_loop</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81kthreadd%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8"><span class="toc-number">3.</span> <span class="toc-text">二、kthreadd进程启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-kthreadd"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 kthreadd</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-create-kthread"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 create_kthread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-kthread"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 kthread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-kthread-create-amp-kthread-run"><span class="toc-number">3.4.</span> <span class="toc-text">2.4 kthread_create &amp; kthread_run</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-kthread-create-on-node"><span class="toc-number">3.5.</span> <span class="toc-text">2.5 kthread_create_on_node</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81init%E8%BF%9B%E7%A8%8B%E5%90%AF%E5%8A%A8"><span class="toc-number">4.</span> <span class="toc-text">三、init进程启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-kernel-init"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 kernel_init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-kernel-init-freeable"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 kernel_init_freeable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-do-basic-setup"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 do_basic_setup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-driver-init"><span class="toc-number">4.4.</span> <span class="toc-text">3.4 driver_init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-free-initmem"><span class="toc-number">4.5.</span> <span class="toc-text">3.5 free_initmem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-6-flush-delayed-fput"><span class="toc-number">4.6.</span> <span class="toc-text">3.6 flush_delayed_fput</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-7-run-init-process"><span class="toc-number">4.7.</span> <span class="toc-text">3.7 run_init_process</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/202304/opencv/OpenCV%20API%EF%BC%9AHoughLines()%E5%92%8CHoughLinesP()%E5%87%BD%E6%95%B0.html" title="OpenCV API：HoughLines()和HoughLinesP()函数"><img src="/imgs/c4.jpg" onerror="this.onerror=null;this.src='/imgs/404.jpg'" alt="OpenCV API：HoughLines()和HoughLinesP()函数"/></a><div class="content"><a class="title" href="/202304/opencv/OpenCV%20API%EF%BC%9AHoughLines()%E5%92%8CHoughLinesP()%E5%87%BD%E6%95%B0.html" title="OpenCV API：HoughLines()和HoughLinesP()函数">OpenCV API：HoughLines()和HoughLinesP()函数</a><time datetime="2023-04-23T07:18:00.000Z" title="发表于 2023-04-23 15:18:00">2023-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/202304/opencv/OpenCV%20API%EF%BC%9Athreshold()%E5%87%BD%E6%95%B0.html" title="OpenCV API：threshold()函数"><img src="/imgs/c4.jpg" onerror="this.onerror=null;this.src='/imgs/404.jpg'" alt="OpenCV API：threshold()函数"/></a><div class="content"><a class="title" href="/202304/opencv/OpenCV%20API%EF%BC%9Athreshold()%E5%87%BD%E6%95%B0.html" title="OpenCV API：threshold()函数">OpenCV API：threshold()函数</a><time datetime="2023-04-22T07:18:00.000Z" title="发表于 2023-04-22 15:18:00">2023-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/202304/android/remote%20write%20failed%EF%BC%9ANo%20space%20left%20on%20device.html" title="remote write failed：No space left on device"><img src="/imgs/c4.jpg" onerror="this.onerror=null;this.src='/imgs/404.jpg'" alt="remote write failed：No space left on device"/></a><div class="content"><a class="title" href="/202304/android/remote%20write%20failed%EF%BC%9ANo%20space%20left%20on%20device.html" title="remote write failed：No space left on device">remote write failed：No space left on device</a><time datetime="2023-04-19T03:30:00.000Z" title="发表于 2023-04-19 11:30:00">2023-04-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/202304/opencv/1%E3%80%81%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E6%A6%82%E5%BF%B5%E3%80%81%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.html" title="1、图像分割概念、原理和算法实现"><img src="/imgs/c2.jpg" onerror="this.onerror=null;this.src='/imgs/404.jpg'" alt="1、图像分割概念、原理和算法实现"/></a><div class="content"><a class="title" href="/202304/opencv/1%E3%80%81%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E6%A6%82%E5%BF%B5%E3%80%81%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.html" title="1、图像分割概念、原理和算法实现">1、图像分割概念、原理和算法实现</a><time datetime="2023-04-11T07:18:00.000Z" title="发表于 2023-04-11 15:18:00">2023-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/202304/opencv/0%E3%80%81vscode+python+opencv%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html" title="0、vscode+python+opencv环境配置"><img src="/imgs/c5.jpg" onerror="this.onerror=null;this.src='/imgs/404.jpg'" alt="0、vscode+python+opencv环境配置"/></a><div class="content"><a class="title" href="/202304/opencv/0%E3%80%81vscode+python+opencv%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html" title="0、vscode+python+opencv环境配置">0、vscode+python+opencv环境配置</a><time datetime="2023-04-11T03:30:00.000Z" title="发表于 2023-04-11 11:30:00">2023-04-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2023 By 赖兴兵</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Stay Hungry, Stay Foolish</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>