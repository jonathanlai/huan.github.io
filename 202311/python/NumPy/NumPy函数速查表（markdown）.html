<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>NumPy函数速查表（markdown） | Jona's Blog</title><meta name="author" content="赖兴兵"><meta name="copyright" content="赖兴兵"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#FFFBFF"><meta name="description" content="将知乎上一篇NumPy函数速查表整理成了markdown文件，方便保存、查看">
<meta property="og:type" content="article">
<meta property="og:title" content="NumPy函数速查表（markdown）">
<meta property="og:url" content="http://huanyuan.mobi/202311/python/NumPy/NumPy%E5%87%BD%E6%95%B0%E9%80%9F%E6%9F%A5%E8%A1%A8%EF%BC%88markdown%EF%BC%89.html">
<meta property="og:site_name" content="Jona&#39;s Blog">
<meta property="og:description" content="将知乎上一篇NumPy函数速查表整理成了markdown文件，方便保存、查看">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://huanyuan.mobi/imgs/202311/20231123180847.png">
<meta property="article:published_time" content="2023-11-23T10:01:33.661Z">
<meta property="article:modified_time" content="2023-11-23T10:12:40.944Z">
<meta property="article:author" content="赖兴兵">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="常用API">
<meta property="article:tag" content="NumPy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://huanyuan.mobi/imgs/202311/20231123180847.png"><link rel="shortcut icon" href="/imgs/avatar.jpg"><link rel="canonical" href="http://huanyuan.mobi/202311/python/NumPy/NumPy%E5%87%BD%E6%95%B0%E9%80%9F%E6%9F%A5%E8%A1%A8%EF%BC%88markdown%EF%BC%89.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="codeva-i31VjpiWuu"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5fba8e4140079c36623565d1c9885852";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-0GBY2PNEKY"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', '[object Object]');
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'NumPy函数速查表（markdown）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-11-23 18:12:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#1C1B1E')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#FFFBFF')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/imgs/avatar.jpg" onerror="onerror=null;src='/imgs/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-compass"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-coffee"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 照片墙</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-user-friends"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/imgs/202311/20231123180847.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Jona's Blog"><span class="site-name">Jona's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-compass"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-coffee"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fas fa-camera-retro"></i><span> 照片墙</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-user-friends"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">NumPy函数速查表（markdown）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-11-23T10:01:33.661Z" title="发表于 2023-11-23 18:01:33">2023-11-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-11-23T10:12:40.944Z" title="更新于 2023-11-23 18:12:40">2023-11-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI/">AI</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI/Python/">Python</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/AI/Python/%E5%B8%B8%E7%94%A8API/">常用API</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="NumPy函数速查表（markdown）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="/imgs/202311/20231123180847.png"></p>
<p>内容整理自<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/445330455">Numpy API 速查表 - 知乎 (zhihu.com)</a>，整理成MD文档。</p>
<h1 id="1、创建数组"><a href="#1、创建数组" class="headerlink" title="1、创建数组"></a>1、创建数组</h1><h2 id="1-1-用1和0创建数组"><a href="#1-1-用1和0创建数组" class="headerlink" title="1.1 用1和0创建数组"></a>1.1 用1和0创建数组</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>empty(shape[, dtype, order])</td>
<td>返回给定形状和类型的新数组，而不初始化条目。</td>
</tr>
<tr>
<td>empty_like(a[, dtype, order, subok])</td>
<td>返回与给定数组形状和类型相同的新数组。</td>
</tr>
<tr>
<td>eye(N[, M, k, dtype, order])</td>
<td>返回对角线上为1、别处为0的二维数组。</td>
</tr>
<tr>
<td>identity(n[, dtype])</td>
<td>返回标识数组。</td>
</tr>
<tr>
<td>ones(shape[, dtype, order])</td>
<td>返回给定形状和类型的新数组，其中填充了一个。</td>
</tr>
<tr>
<td>ones_like(a[, dtype, order, subok])</td>
<td>返回与给定数组形状和类型相同的数组。</td>
</tr>
<tr>
<td>zeros(shape[, dtype, order])</td>
<td>返回给定形状和类型的新数组，用零填充。</td>
</tr>
<tr>
<td>zeros_like(a[, dtype, order, subok])</td>
<td>返回与给定数组形状和类型相同的零数组。</td>
</tr>
<tr>
<td>full(shape, fill_value[, dtype, order])</td>
<td>返回给定形状和类型的新数组，用 fill_value 填充。</td>
</tr>
<tr>
<td>full_like(a, fill_value[, dtype, order, subok])</td>
<td>返回与给定数组形状和类型相同的完整数组。</td>
</tr>
</tbody></table>
<h2 id="1-2-根据现有数据创建数组"><a href="#1-2-根据现有数据创建数组" class="headerlink" title="1.2 根据现有数据创建数组"></a>1.2 根据现有数据创建数组</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>array(object[, dtype, copy, order, subok, ndmin])</td>
<td>创建一个数组。</td>
</tr>
<tr>
<td>asarray(a[, dtype, order])</td>
<td>将输入转换为数组。</td>
</tr>
<tr>
<td>asanyarray(a[, dtype, order])</td>
<td>将输入转换为ndarray，但将ndarray子类传递到。</td>
</tr>
<tr>
<td>ascontiguousarray(a[, dtype])</td>
<td>返回内存中的连续数组( C顺序)。</td>
</tr>
<tr>
<td>asmatrix(data[, dtype])</td>
<td>将输入解释为矩阵。</td>
</tr>
<tr>
<td>copy(a[, order])</td>
<td>返回给定对象的数组副本。</td>
</tr>
<tr>
<td>frombuffer(buffer[, dtype, count, offset])</td>
<td>将缓冲区解释为一维数组。</td>
</tr>
<tr>
<td>fromfile(file[, dtype, count, sep])</td>
<td>从文本或二进制文件中的数据构造数组。</td>
</tr>
<tr>
<td>fromfunction(function, shape, **kwargs)</td>
<td>通过在每个坐标上执行函数来构造数组。</td>
</tr>
<tr>
<td>fromiter(iterable, dtype[, count])</td>
<td>从可迭代对象创建新的一维数组。</td>
</tr>
<tr>
<td>fromstring(string[, dtype, count, sep])</td>
<td>从字符串中的文本数据初始化的新一维数组。</td>
</tr>
<tr>
<td>loadtxt(fname[, dtype, comments, delimiter, …])</td>
<td>从文本文件加载数据。</td>
</tr>
</tbody></table>
<h2 id="1-3-创建记录数组-np-rec"><a href="#1-3-创建记录数组-np-rec" class="headerlink" title="1.3 创建记录数组(np.rec)"></a>1.3 创建记录数组(np.rec)</h2><p>这里 <code>numpy.rec</code> 是 <code>numpy.core.records</code> 的首选别名。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>core.records.array(obj[, dtype, shape, …])</td>
<td>从各种各样的对象构造记录数组。</td>
</tr>
<tr>
<td>core.records.fromarrays(arrayList[, dtype, …])</td>
<td>从(平面)数组列表中创建记录数组</td>
</tr>
<tr>
<td>core.records.fromrecords(recList[, dtype, …])</td>
<td>从文本形式的记录列表中创建重新排列</td>
</tr>
<tr>
<td>core.records.fromstring(datastring[, dtype, …])</td>
<td>从字符串中包含的二进制数据创建(只读)记录数组</td>
</tr>
<tr>
<td>core.records.fromfile(fd[, dtype, shape, …])</td>
<td>从二进制文件数据创建数组</td>
</tr>
</tbody></table>
<h2 id="1-4-创建字符数组-np-char"><a href="#1-4-创建字符数组-np-char" class="headerlink" title="1.4 创建字符数组(np.char)"></a>1.4 创建字符数组(np.char)</h2><p>这里 numpy.char 是 numpy.core.defcharary 的首选别名。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>core.defchararray.array(obj[, itemsize, …])</td>
<td>创建一个字符数组。</td>
</tr>
<tr>
<td>core.defchararray.asarray(obj[, itemsize, …])</td>
<td>将输入转换为字符数组，仅在必要时复制数据。</td>
</tr>
</tbody></table>
<h2 id="1-5-根据数值范围创建数组"><a href="#1-5-根据数值范围创建数组" class="headerlink" title="1.5 根据数值范围创建数组"></a>1.5 根据数值范围创建数组</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>arange([start,] stop[, step,][, dtype])</td>
<td>在给定间隔内返回均匀间隔的值。</td>
</tr>
<tr>
<td>linspace(start, stop[, num, endpoint, …])</td>
<td>在指定的时间间隔内返回均匀间隔的数字。</td>
</tr>
<tr>
<td>logspace(start, stop[, num, endpoint, base, …])</td>
<td>返回对数刻度上均匀间隔的数字。</td>
</tr>
<tr>
<td>geomspace(start, stop[, num, endpoint, dtype])</td>
<td>返回对数刻度上均匀间隔的数字(几何级数)。</td>
</tr>
<tr>
<td>meshgrid(xi, *kwargs)</td>
<td>从坐标向量返回坐标矩阵。</td>
</tr>
<tr>
<td>mgrid</td>
<td>nd_grid 实例，返回密集的多维“网格”。</td>
</tr>
<tr>
<td>ogrid</td>
<td>返回开放多维“网格”的 nd_grid 实例。</td>
</tr>
</tbody></table>
<h2 id="1-6-创建特殊矩阵"><a href="#1-6-创建特殊矩阵" class="headerlink" title="1.6 创建特殊矩阵"></a>1.6 创建特殊矩阵</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>diag(v[, k])</td>
<td>提取对角线或构造对角线数组。</td>
</tr>
<tr>
<td>diagflat(v[, k])</td>
<td>以展平的输入为对角线创建二维数组。</td>
</tr>
<tr>
<td>tri(N[, M, k, dtype])</td>
<td>一个数组，在给定对角线上和下方有一个，在其他地方有零。</td>
</tr>
<tr>
<td>tril(m[, k])</td>
<td>数组的下三角形。</td>
</tr>
<tr>
<td>triu(m[, k])</td>
<td>数组的上三角形。</td>
</tr>
<tr>
<td>vander(x[, N, increasing])</td>
<td>生成范德蒙矩阵。</td>
</tr>
</tbody></table>
<h2 id="1-7-创建矩阵"><a href="#1-7-创建矩阵" class="headerlink" title="1.7 创建矩阵"></a>1.7 创建矩阵</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>mat(data[, dtype])</td>
<td>将输入解释为矩阵。</td>
</tr>
<tr>
<td>bmat(obj[, ldict, gdict])</td>
<td>从字符串、嵌套序列或数组构建矩阵对象。</td>
</tr>
</tbody></table>
<hr>
<h1 id="2、数组操作"><a href="#2、数组操作" class="headerlink" title="2、数组操作"></a>2、数组操作</h1><h2 id="2-1-复制"><a href="#2-1-复制" class="headerlink" title="2.1 复制"></a>2.1 复制</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>copyto(dst, src[, casting, where])</td>
<td>将值从一个阵列复制到另一个阵列，根据需要进行广播。</td>
</tr>
</tbody></table>
<h2 id="2-2-改变形状"><a href="#2-2-改变形状" class="headerlink" title="2.2 改变形状"></a>2.2 改变形状</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>reshape(a, newshape[, order])</td>
<td>在不更改数组数据的情况下为数组赋予新形状。</td>
</tr>
<tr>
<td>ravel(a[, order])</td>
<td>返回连续的扁平数组。</td>
</tr>
<tr>
<td>ndarray.flat</td>
<td>数组上的一维迭代器。</td>
</tr>
<tr>
<td>ndarray.flatten([order])</td>
<td>返回折叠到一维中的数组副本。</td>
</tr>
</tbody></table>
<h2 id="2-3-置换坐标轴"><a href="#2-3-置换坐标轴" class="headerlink" title="2.3 置换坐标轴"></a>2.3 置换坐标轴</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>moveaxis(a, source, destination)</td>
<td>将数组的轴移动到新位置。</td>
</tr>
<tr>
<td>rollaxis(a, axis[, start])</td>
<td>向后滚动指定的轴，直到它位于给定位置。</td>
</tr>
<tr>
<td>swapaxes(a, axis1, axis2)</td>
<td>交换数组的两个轴。</td>
</tr>
<tr>
<td>ndarray.T</td>
<td>与 self.indim &lt; 2 时返回 self() 相同。</td>
</tr>
<tr>
<td>transpose(a[, axes])</td>
<td>置换数组的维度。</td>
</tr>
</tbody></table>
<h2 id="2-4-改变维数"><a href="#2-4-改变维数" class="headerlink" title="2.4 改变维数"></a>2.4 改变维数</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>atleast_1d(*arys)</td>
<td>将输入转换为至少具有一维的数组。</td>
</tr>
<tr>
<td>atleast_2d(*arys)</td>
<td>将输入视为至少具有两个维度的数组。</td>
</tr>
<tr>
<td>atleast_3d(*arys)</td>
<td>将输入视为至少具有三维的数组。</td>
</tr>
<tr>
<td>broadcast</td>
<td>制作模拟广播的对象。</td>
</tr>
<tr>
<td>broadcast_to(array, shape[, subok])</td>
<td>将数组广播到新形状。</td>
</tr>
<tr>
<td>broadcast_arrays(args, *kwargs)</td>
<td>相互广播任意数量的阵列。</td>
</tr>
<tr>
<td>expand_dims(a, axis)</td>
<td>展开数组的形状。</td>
</tr>
<tr>
<td>squeeze(a[, axis])</td>
<td>从数组形状中删除一维条目。</td>
</tr>
</tbody></table>
<h2 id="2-5-改变数组种类"><a href="#2-5-改变数组种类" class="headerlink" title="2.5 改变数组种类"></a>2.5 改变数组种类</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>asarray(a[, dtype, order])</td>
<td>将输入转换为数组。</td>
</tr>
<tr>
<td>asanyarray(a[, dtype, order])</td>
<td>将输入转换为ndarray，但将ndarray子类传递到。</td>
</tr>
<tr>
<td>asmatrix(data[, dtype])</td>
<td>将输入解释为矩阵。</td>
</tr>
<tr>
<td>asfarray(a[, dtype])</td>
<td>返回转换为浮点型的数组。</td>
</tr>
<tr>
<td>asfortranarray(a[, dtype])</td>
<td>在内存中返回按Fortran顺序排列的数组。</td>
</tr>
<tr>
<td>ascontiguousarray(a[, dtype])</td>
<td>返回内存中的连续数组( C顺序)。</td>
</tr>
<tr>
<td>asarray_chkfinite(a[, dtype, order])</td>
<td>将输入转换为数组，检查NaNs或Infs。</td>
</tr>
<tr>
<td>asscalar(a)</td>
<td>将大小为1的数组转换为其标量等效数组。</td>
</tr>
<tr>
<td>require(a[, dtype, requirements])</td>
<td>返回满足要求的所提供类型的ndarray。</td>
</tr>
</tbody></table>
<h2 id="2-6-连接数组"><a href="#2-6-连接数组" class="headerlink" title="2.6 连接数组"></a>2.6 连接数组</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>concatenate((a1, a2, …)[, axis, out])</td>
<td>沿现有轴连接阵列序列。</td>
</tr>
<tr>
<td>stack(arrays[, axis, out])</td>
<td>沿着新轴连接一系列数组。</td>
</tr>
<tr>
<td>column_stack(tup)</td>
<td>将一维数组作为列堆叠成二维数组。</td>
</tr>
<tr>
<td>dstack(tup)</td>
<td>按顺序深度(沿第三轴)堆叠阵列。</td>
</tr>
<tr>
<td>hstack(tup)</td>
<td>水平(按列)按顺序堆叠数组。</td>
</tr>
<tr>
<td>vstack(tup)</td>
<td>垂直(按行)顺序堆叠阵列。</td>
</tr>
<tr>
<td>block(arrays)</td>
<td>从嵌套的块列表中组装nd数组。</td>
</tr>
</tbody></table>
<h2 id="2-7-分裂数组"><a href="#2-7-分裂数组" class="headerlink" title="2.7 分裂数组"></a>2.7 分裂数组</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>split(ary, indices_or_sections[, axis])</td>
<td>将阵列分割成多个子阵列。</td>
</tr>
<tr>
<td>array_split(ary, indices_or_sections[, axis])</td>
<td>将阵列分割成多个子阵列。</td>
</tr>
<tr>
<td>dsplit(ary, indices_or_sections)</td>
<td>沿第三轴(深度)将阵列分割成多个子阵列。</td>
</tr>
<tr>
<td>hsplit(ary, indices_or_sections)</td>
<td>水平(按列)将阵列拆分为多个子阵列。</td>
</tr>
<tr>
<td>vsplit(ary, indices_or_sections)</td>
<td>将阵列垂直(按行)拆分为多个子阵列。</td>
</tr>
</tbody></table>
<h2 id="2-8-平铺数组"><a href="#2-8-平铺数组" class="headerlink" title="2.8 平铺数组"></a>2.8 平铺数组</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>tile(A, reps)</td>
<td>通过重复代表给定的次数来构造数组</td>
</tr>
<tr>
<td>repeat(a, repeats[, axis])</td>
<td>重复数组的元素。</td>
</tr>
</tbody></table>
<h2 id="2-9-添加和删除元素"><a href="#2-9-添加和删除元素" class="headerlink" title="2.9 添加和删除元素"></a>2.9 添加和删除元素</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>delete(arr, obj[, axis])</td>
<td>返回删除了沿轴的子阵列的新阵列。</td>
</tr>
<tr>
<td>insert(arr, obj, values[, axis])</td>
<td>在给定索引之前沿给定轴插入值。</td>
</tr>
<tr>
<td>append(arr, values[, axis])</td>
<td>将值追加到数组的末尾。</td>
</tr>
<tr>
<td>resize(a, new_shape)</td>
<td>返回具有指定形状的新数组。</td>
</tr>
<tr>
<td>trim_zeros(filt[, trim])</td>
<td>从一维数组或序列中修剪前导零和&#x2F;或尾随零。</td>
</tr>
<tr>
<td>unique(ar[, return_index, return_inverse, …])</td>
<td>查找数组的唯一元素。</td>
</tr>
</tbody></table>
<h2 id="2-10-重新排列元素"><a href="#2-10-重新排列元素" class="headerlink" title="2.10 重新排列元素"></a>2.10 重新排列元素</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>flip(m, axis)</td>
<td>沿给定轴反转数组中元素的顺序。</td>
</tr>
<tr>
<td>fliplr(m)</td>
<td>向左&#x2F;向右翻转阵列。</td>
</tr>
<tr>
<td>flipud(m)</td>
<td>沿上下方向翻转阵列。</td>
</tr>
<tr>
<td>reshape(a, newshape[, order])</td>
<td>在不更改数组数据的情况下为数组赋予新形状。</td>
</tr>
<tr>
<td>roll(a, shift[, axis])</td>
<td>沿给定轴滚动阵列元素。</td>
</tr>
<tr>
<td>rot90(m[, k, axes])</td>
<td>在轴指定的平面中将阵列旋转90度。</td>
</tr>
</tbody></table>
<hr>
<h1 id="3、二进制操作"><a href="#3、二进制操作" class="headerlink" title="3、二进制操作"></a>3、二进制操作</h1><h2 id="3-1-元素位操作"><a href="#3-1-元素位操作" class="headerlink" title="3.1 元素位操作"></a>3.1 元素位操作</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>bitwise_and(x1, x2, &#x2F;[, out, where, …])</td>
<td>逐位计算两个数组的“与”。</td>
</tr>
<tr>
<td>bitwise_or(x1, x2, &#x2F;[, out, where, casting, …])</td>
<td>逐位计算两个数组的OR。</td>
</tr>
<tr>
<td>bitwise_xor(x1, x2, &#x2F;[, out, where, …])</td>
<td>逐元素计算两个数组的位异或。</td>
</tr>
<tr>
<td>invert(x, &#x2F;[, out, where, casting, order, …])</td>
<td>逐位或逐位不逐元素计算反演。</td>
</tr>
<tr>
<td>left_shift(x1, x2, &#x2F;[, out, where, casting, …])</td>
<td>将整数的位向左移动。</td>
</tr>
<tr>
<td>right_shift(x1, x2, &#x2F;[, out, where, …])</td>
<td>将整数的位向右移动。</td>
</tr>
</tbody></table>
<h2 id="3-2-字节打包"><a href="#3-2-字节打包" class="headerlink" title="3.2 字节打包"></a>3.2 字节打包</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>packbits(myarray[, axis])</td>
<td>将二进制值数组的元素打包成uint 8数组中的位。</td>
</tr>
<tr>
<td>unpackbits(myarray[, axis])</td>
<td>将uint 8数组的元素解包为二进制值输出数组。</td>
</tr>
</tbody></table>
<h2 id="3-3-输出格式"><a href="#3-3-输出格式" class="headerlink" title="3.3 输出格式"></a>3.3 输出格式</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>binary_repr(num[, width])</td>
<td>将输入数字的二进制表示形式返回为字符串。</td>
</tr>
</tbody></table>
<h1 id="4、操作字符串"><a href="#4、操作字符串" class="headerlink" title="4、操作字符串"></a>4、操作字符串</h1><h2 id="4-1-字符串操作"><a href="#4-1-字符串操作" class="headerlink" title="4.1 字符串操作"></a>4.1 字符串操作</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>add(x1, x2)</td>
<td>返回字符串或unicode两个数组的逐元素字符串连接。</td>
</tr>
<tr>
<td>multiply(a, i)</td>
<td>返回( a * I )，即字符串多重连接，按元素排序。</td>
</tr>
<tr>
<td>mod(a, values)</td>
<td>返回( a % I )，即Python 2.6之前的字符串格式( iterpolation )，对于字符串或unicode这样的一对array_likes，逐元素返回。</td>
</tr>
<tr>
<td>capitalize(a)</td>
<td>返回一个副本，其中每个元素的第一个字符都是大写的。</td>
</tr>
<tr>
<td>center(a, width[, fillchar])</td>
<td>传回的复本，其元素以长度宽度字串为中心。</td>
</tr>
<tr>
<td>decode(a[, encoding, errors])</td>
<td>逐元素调用字符串解码。</td>
</tr>
<tr>
<td>encode(a[, encoding, errors])</td>
<td>调用字符串按元素编码。</td>
</tr>
<tr>
<td>join(sep, seq)</td>
<td>返回一个字符串，它是序列seq中字符串的串联。</td>
</tr>
<tr>
<td>ljust(a, width[, fillchar])</td>
<td>返回一个数组，数组中的元素在长度为宽度的字符串中左对齐。</td>
</tr>
<tr>
<td>lower(a)</td>
<td>返回元素转换为小写的数组。</td>
</tr>
<tr>
<td>lstrip(a[, chars])</td>
<td>对于中的每个元素，返回删除前导字符的副本。</td>
</tr>
<tr>
<td>partition(a, sep)</td>
<td>9月份左右，将每个元素分区</td>
</tr>
<tr>
<td>replace(a, old, new[, count])</td>
<td>对于中的每个元素，返回字符串的副本，所有出现的子字符串旧的都替换为新的。</td>
</tr>
<tr>
<td>rjust(a, width[, fillchar])</td>
<td>返回一个数组，数组中的元素在长度为宽度的字符串中右对齐。</td>
</tr>
<tr>
<td>rpartition(a, sep)</td>
<td>分隔(拆分)最右边分隔符周围的每个元素。</td>
</tr>
<tr>
<td>rsplit(a[, sep, maxsplit])</td>
<td>对于中的每个元素，使用sep作为分隔符字符串返回字符串中的单词列表。</td>
</tr>
<tr>
<td>rstrip(a[, chars])</td>
<td>对于中的每个元素，返回一个删除了尾随字符的副本。</td>
</tr>
<tr>
<td>split(a[, sep, maxsplit])</td>
<td>对于中的每个元素，使用sep作为分隔符字符串返回字符串中的单词列表。</td>
</tr>
<tr>
<td>splitlines(a[, keepends])</td>
<td>对于中的每个元素，返回元素中的线条列表，在线条边界处断开。</td>
</tr>
<tr>
<td>strip(a[, chars])</td>
<td>对于a中的每个元素，返回一个删除了前导和尾随字符的副本。</td>
</tr>
<tr>
<td>swapcase(a)</td>
<td>以元素方式返回字符串副本，大写字符转换为小写字符，反之亦然。</td>
</tr>
<tr>
<td>title(a)</td>
<td>返回字符串或unicode的元素标题大小写版本。</td>
</tr>
<tr>
<td>translate(a, table[, deletechars])</td>
<td>对于中的每个元素，返回字符串的副本，在该副本中，可选参数deletechars中出现的所有字符都被删除，其余字符已通过给定的转换表映射。</td>
</tr>
<tr>
<td>upper(a)</td>
<td>返回元素转换为大写的数组。</td>
</tr>
<tr>
<td>zfill(a, width)</td>
<td>返回左填充零的数字字符串</td>
</tr>
</tbody></table>
<h2 id="4-2-比较"><a href="#4-2-比较" class="headerlink" title="4.2 比较"></a>4.2 比较</h2><p>与标准numpy比较运算符不同的是，char模块中的运算符在执行比较之前会剥离尾随空白字符。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>equal(x1, x2)</td>
<td>按元素返回( x1 &#x3D; &#x3D; x2 )。</td>
</tr>
<tr>
<td>not_equal(x1, x2)</td>
<td>返回( x1！&#x3D; x2 )元素方式。</td>
</tr>
<tr>
<td>greater_equal(x1, x2)</td>
<td>逐元素返回( x1 &gt; &#x3D; x2 )。</td>
</tr>
<tr>
<td>less_equal(x1, x2)</td>
<td>逐元素返回( x1 &lt; &#x3D; x2 )。</td>
</tr>
<tr>
<td>greater(x1, x2)</td>
<td>逐元素返回( x1 &gt; x2 )。</td>
</tr>
<tr>
<td>less(x1, x2)</td>
<td>逐元素返回( x1 &lt; x2 )。</td>
</tr>
</tbody></table>
<h2 id="4-3-字符串信息"><a href="#4-3-字符串信息" class="headerlink" title="4.3 字符串信息"></a>4.3 字符串信息</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>count(a, sub[, start, end])</td>
<td>返回一个数组，其中子字符串sub在“[开始，结束)”范围内不重叠的出现次数。</td>
</tr>
<tr>
<td>find(a, sub[, start, end])</td>
<td>对于每个元素，返回字符串中找到子字符串sub的最低索引。</td>
</tr>
<tr>
<td>index(a, sub[, start, end])</td>
<td>如查找，但在未找到子字符串时引发值错误。</td>
</tr>
<tr>
<td>isalpha(a)</td>
<td>如果字符串中的所有字符都是字母，并且至少有一个字符，则返回true，否则返回false。</td>
</tr>
<tr>
<td>isdecimal(a)</td>
<td>对于每个元素，如果元素中只有十进制字符，则返回True。</td>
</tr>
<tr>
<td>isdigit(a)</td>
<td>如果字符串中的所有字符都是数字，并且至少有一个字符，则返回true，否则返回false。</td>
</tr>
<tr>
<td>islower(a)</td>
<td>如果字符串中的所有大小写字符都是小写的，并且至少有一个大小写字符，则返回true，否则返回false。</td>
</tr>
<tr>
<td>isnumeric(a)</td>
<td>对于每个元素，如果元素中只有数字字符，则返回True。</td>
</tr>
<tr>
<td>isspace(a)</td>
<td>如果字符串中只有空白字符，并且至少有一个字符，则返回true，否则返回false。</td>
</tr>
<tr>
<td>istitle(a)</td>
<td>如果元素是标题大小写字符串，并且至少有一个字符，则返回true，否则返回false。</td>
</tr>
<tr>
<td>isupper(a)</td>
<td>如果字符串中的所有大小写字符都是大写的，并且至少有一个字符，则返回true，否则返回false。</td>
</tr>
<tr>
<td>rfind(a, sub[, start, end])</td>
<td>对于a中的每个元素，返回字符串中找到substring sub的最高索引，以便sub包含在[ start，end ]中。</td>
</tr>
<tr>
<td>rindex(a, sub[, start, end])</td>
<td>类似rfind，但在未找到子字符串子字符串时引发值错误。</td>
</tr>
<tr>
<td>startswith(a, prefix[, start, end])</td>
<td>返回一个布尔数组，该数组为True，其中a中的字符串元素以前缀开头，否则为False。</td>
</tr>
</tbody></table>
<hr>
<h1 id="5、日期支持"><a href="#5、日期支持" class="headerlink" title="5、日期支持"></a>5、日期支持</h1><h2 id="5-1-日期时间支持函数"><a href="#5-1-日期时间支持函数" class="headerlink" title="5.1 日期时间支持函数"></a>5.1 日期时间支持函数</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>datetime_as_string(arr[, unit, timezone, …])</td>
<td>将日期时间数组转换为字符串数组。</td>
</tr>
<tr>
<td>datetime_data(dtype, &#x2F;)</td>
<td>获取有关日期或时间类型步长的信息。</td>
</tr>
</tbody></table>
<h2 id="5-2-营业日功能"><a href="#5-2-营业日功能" class="headerlink" title="5.2 营业日功能"></a>5.2 营业日功能</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>busdaycalendar([weekmask, holidays])</td>
<td>一个工作日日历对象，有效存储定义工作日系列功能的有效天数的信息。</td>
</tr>
<tr>
<td>is_busday(dates[, weekmask, holidays, …])</td>
<td>计算给定日期中哪些是有效天数，哪些不是。</td>
</tr>
<tr>
<td>busday_offset(dates, offsets[, roll, …])</td>
<td>首先根据滚动规则将日期调整为有效日期，然后将偏移应用于以有效日期计算的给定日期。</td>
</tr>
<tr>
<td>busday_count(begindates, enddates[, …])</td>
<td>计算开始日期和结束日期之间的有效天数，不包括结束日期。</td>
</tr>
</tbody></table>
<hr>
<h1 id="6、数据类型"><a href="#6、数据类型" class="headerlink" title="6、数据类型"></a>6、数据类型</h1><h2 id="6-1-数据类型检查"><a href="#6-1-数据类型检查" class="headerlink" title="6.1 数据类型检查"></a>6.1 数据类型检查</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>can_cast(from_, to[, casting])</td>
<td>如果可以根据转换规则在数据类型之间进行转换，则返回True。</td>
</tr>
<tr>
<td>promote_types(type1, type2)</td>
<td>返回具有最小大小和最小标量类型的数据类型，类型1和类型2都可以安全地转换到该数据类型。</td>
</tr>
<tr>
<td>min_scalar_type(a)</td>
<td>对于标量a，返回大小最小且标量种类最小的数据类型，该数据类型可以保存其值。</td>
</tr>
<tr>
<td>result_type(*arrays_and_dtypes)</td>
<td>传回将NumPy型别升级规则套用至引数所产生的型别。</td>
</tr>
<tr>
<td>common_type(*arrays)</td>
<td>返回输入数组共有的标量类型。</td>
</tr>
<tr>
<td>obj2sctype(rep[, default])</td>
<td>返回对象Python类型的标量dtype或NumPy等效项。</td>
</tr>
</tbody></table>
<h2 id="6-2-创建数据类型"><a href="#6-2-创建数据类型" class="headerlink" title="6.2 创建数据类型"></a>6.2 创建数据类型</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>dtype(obj[, align, copy])</td>
<td>创建数据类型对象。</td>
</tr>
<tr>
<td>format_parser(formats, names, titles[, …])</td>
<td>类将格式、名称、标题描述转换为dtype。</td>
</tr>
</tbody></table>
<h2 id="6-3-数据类型信息"><a href="#6-3-数据类型信息" class="headerlink" title="6.3 数据类型信息"></a>6.3 数据类型信息</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>finfo(dtype)</td>
<td>浮点类型的机器限制。</td>
</tr>
<tr>
<td>iinfo(type)</td>
<td>整数类型的机器限制。</td>
</tr>
<tr>
<td>MachAr([float_conv, int_conv, …])</td>
<td>诊断机器参数。</td>
</tr>
</tbody></table>
<h2 id="6-4-数据类型测试"><a href="#6-4-数据类型测试" class="headerlink" title="6.4 数据类型测试"></a>6.4 数据类型测试</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>issctype(rep)</td>
<td>确定给定对象是否表示标量数据类型。</td>
</tr>
<tr>
<td>issubdtype(arg1, arg2)</td>
<td>如果第一个参数是类型层次结构中较低&#x2F;相等的类型代码，则返回True。</td>
</tr>
<tr>
<td>issubsctype(arg1, arg2)</td>
<td>确定第一个参数是否是第二个参数的子类。</td>
</tr>
<tr>
<td>issubclass_(arg1, arg2)</td>
<td>确定一个类是否是第二类的子类。</td>
</tr>
<tr>
<td>find_common_type(array_types, scalar_types)</td>
<td>按照标准强制规则确定通用类型。</td>
</tr>
</tbody></table>
<h2 id="6-5-其它"><a href="#6-5-其它" class="headerlink" title="6.5 其它"></a>6.5 其它</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>typename(char)</td>
<td>返回给定数据类型代码的描述。</td>
</tr>
<tr>
<td>sctype2char(sctype)</td>
<td>返回标量dtype的字符串表示形式。</td>
</tr>
<tr>
<td>mintypecode(typechars[, typeset, default])</td>
<td>返回给定类型可以安全转换到的最小大小类型的字符。</td>
</tr>
</tbody></table>
<hr>
<h1 id="7、可选的Scipy加速from-numpy-dual-import"><a href="#7、可选的Scipy加速from-numpy-dual-import" class="headerlink" title="7、可选的Scipy加速from numpy.dual import..."></a>7、可选的Scipy加速<code>from numpy.dual import...</code></h1><p>scipy可以被构建为使用加速库或其他改进库来实现FFTs、线性代数和特殊函数。</p>
<h2 id="7-1-线性代数"><a href="#7-1-线性代数" class="headerlink" title="7.1 线性代数"></a>7.1 线性代数</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>cholesky(a)</td>
<td>乔利斯基分解。</td>
</tr>
<tr>
<td>det(a)</td>
<td>计算数组的行列式。</td>
</tr>
<tr>
<td>eig(a)</td>
<td>计算方阵的特征值和右特征向量。</td>
</tr>
<tr>
<td>eigh(a[, UPLO])</td>
<td>返回埃尔米特矩阵或对称矩阵的特征值和特征向量。</td>
</tr>
<tr>
<td>eigvals(a)</td>
<td>计算一般矩阵的特征值。</td>
</tr>
<tr>
<td>eigvalsh(a[, UPLO])</td>
<td>计算埃尔米特矩阵或实对称矩阵的特征值。</td>
</tr>
<tr>
<td>inv(a)</td>
<td>计算矩阵的(乘法)逆。</td>
</tr>
<tr>
<td>lstsq(a, b[, rcond])</td>
<td>将最小二乘解返回线性矩阵方程。</td>
</tr>
<tr>
<td>norm(x[, ord, axis, keepdims])</td>
<td>矩阵或向量范数。</td>
</tr>
<tr>
<td>pinv(a[, rcond])</td>
<td>计算矩阵的(摩尔-彭罗斯)伪逆。</td>
</tr>
<tr>
<td>solve(a, b)</td>
<td>求解线性矩阵方程或线性标量方程组。</td>
</tr>
<tr>
<td>svd(a[, full_matrices, compute_uv])</td>
<td>奇异值分解。</td>
</tr>
</tbody></table>
<h2 id="7-2-快速傅里叶变换"><a href="#7-2-快速傅里叶变换" class="headerlink" title="7.2 快速傅里叶变换"></a>7.2 快速傅里叶变换</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>fft(a[, n, axis, norm])</td>
<td>计算一维离散傅立叶变换。</td>
</tr>
<tr>
<td>fft2(a[, s, axes, norm])</td>
<td>计算二维离散傅立叶变换</td>
</tr>
<tr>
<td>fftn(a[, s, axes, norm])</td>
<td>计算N维离散傅立叶变换。</td>
</tr>
<tr>
<td>ifft(a[, n, axis, norm])</td>
<td>计算一维离散傅立叶逆变换。</td>
</tr>
<tr>
<td>ifft2(a[, s, axes, norm])</td>
<td>计算二维离散傅立叶逆变换。</td>
</tr>
<tr>
<td>ifftn(a[, s, axes, norm])</td>
<td>计算N维离散傅立叶逆变换。</td>
</tr>
</tbody></table>
<h2 id="7-3-特殊函数"><a href="#7-3-特殊函数" class="headerlink" title="7.3 特殊函数"></a>7.3 特殊函数</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>i0(x)</td>
<td>第一类修正贝塞尔函数，0阶。</td>
</tr>
</tbody></table>
<hr>
<h1 id="8、浮点错误处理"><a href="#8、浮点错误处理" class="headerlink" title="8、浮点错误处理"></a>8、浮点错误处理</h1><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>seterr([all, divide, over, under, invalid])</td>
<td>设置浮点错误的处理方式。</td>
</tr>
<tr>
<td>geterr()</td>
<td>获取当前处理浮点错误的方式。</td>
</tr>
<tr>
<td>seterrcall(func)</td>
<td>设置浮点错误回调函数或日志对象。</td>
</tr>
<tr>
<td>geterrcall()</td>
<td>返回用于浮点错误的当前回调函数。</td>
</tr>
<tr>
<td>errstate(**kwargs)</td>
<td>浮点错误处理的上下文管理器。</td>
</tr>
<tr>
<td>seterrobj(errobj)</td>
<td>设置定义浮点错误处理的对象。</td>
</tr>
<tr>
<td>geterrobj()</td>
<td>返回定义浮点错误处理的当前对象。</td>
</tr>
</tbody></table>
<hr>
<h1 id="9、离散傅里叶变换from-numpy-fft-import"><a href="#9、离散傅里叶变换from-numpy-fft-import" class="headerlink" title="9、离散傅里叶变换from numpy.fft import..."></a>9、离散傅里叶变换<code>from numpy.fft import...</code></h1><h2 id="9-1-标准快速傅立叶变换"><a href="#9-1-标准快速傅立叶变换" class="headerlink" title="9.1 标准快速傅立叶变换"></a>9.1 标准快速傅立叶变换</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>fft(a[, n, axis, norm])</td>
<td>计算一维离散傅立叶变换。</td>
</tr>
<tr>
<td>ifft(a[, n, axis, norm])</td>
<td>计算一维离散傅立叶逆变换。</td>
</tr>
<tr>
<td>fft2(a[, s, axes, norm])</td>
<td>计算二维离散傅立叶变换</td>
</tr>
<tr>
<td>ifft2(a[, s, axes, norm])</td>
<td>计算二维离散傅立叶逆变换。</td>
</tr>
<tr>
<td>fftn(a[, s, axes, norm])</td>
<td>计算N维离散傅立叶变换。</td>
</tr>
<tr>
<td>ifftn(a[, s, axes, norm])</td>
<td>计算N维离散傅立叶逆变换。</td>
</tr>
</tbody></table>
<h2 id="9-2-实FFTs"><a href="#9-2-实FFTs" class="headerlink" title="9.2 实FFTs"></a>9.2 实FFTs</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>rfft(a[, n, axis, norm])</td>
<td>计算真实输入的一维离散傅立叶变换。</td>
</tr>
<tr>
<td>irfft(a[, n, axis, norm])</td>
<td>计算实际输入的n点DFT的倒数。</td>
</tr>
<tr>
<td>rfft2(a[, s, axes, norm])</td>
<td>计算真实阵列的二维FFT。</td>
</tr>
<tr>
<td>irfft2(a[, s, axes, norm])</td>
<td>计算真实阵列的二维逆FFT。</td>
</tr>
<tr>
<td>rfftn(a[, s, axes, norm])</td>
<td>计算真实输入的N维离散傅立叶变换。</td>
</tr>
<tr>
<td>irfftn(a[, s, axes, norm])</td>
<td>计算实际输入的N维FFT的倒数。</td>
</tr>
</tbody></table>
<h2 id="9-3-埃尔米特快速傅立叶变换"><a href="#9-3-埃尔米特快速傅立叶变换" class="headerlink" title="9.3 埃尔米特快速傅立叶变换"></a>9.3 埃尔米特快速傅立叶变换</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>hfft(a[, n, axis, norm])</td>
<td>计算具有厄米对称的信号的FFT，即实谱。</td>
</tr>
<tr>
<td>ihfft(a[, n, axis, norm])</td>
<td>计算具有厄米对称的信号的逆FFT。</td>
</tr>
</tbody></table>
<h2 id="9-4-其它"><a href="#9-4-其它" class="headerlink" title="9.4 其它"></a>9.4 其它</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>fftfreq(n[, d])</td>
<td>返回离散傅立叶变换采样频率。</td>
</tr>
<tr>
<td>rfftfreq(n[, d])</td>
<td>返回离散傅立叶变换采样频率(用于rfft、irfft )。</td>
</tr>
<tr>
<td>fftshift(x[, axes])</td>
<td>将零频率分量移动到频谱中心。</td>
</tr>
<tr>
<td>ifftshift(x[, axes])</td>
<td>fftshift反向操作。</td>
</tr>
</tbody></table>
<hr>
<h1 id="10、财务"><a href="#10、财务" class="headerlink" title="10、财务"></a>10、财务</h1><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>fv(rate, nper, pmt, pv[, when])</td>
<td>计算未来值。</td>
</tr>
<tr>
<td>pv(rate, nper, pmt[, fv, when])</td>
<td>计算现值。</td>
</tr>
<tr>
<td>npv(rate, values)</td>
<td>返回现金流序列的净现值。</td>
</tr>
<tr>
<td>pmt(rate, nper, pv[, fv, when])</td>
<td>根据贷款本金加利息计算付款。</td>
</tr>
<tr>
<td>ppmt(rate, per, nper, pv[, fv, when])</td>
<td>根据贷款本金计算付款。</td>
</tr>
<tr>
<td>ipmt(rate, per, nper, pv[, fv, when])</td>
<td>计算付款的利息部分。</td>
</tr>
<tr>
<td>irr(values)</td>
<td>返回内部收益率( IRR )。</td>
</tr>
<tr>
<td>mirr(values, finance_rate, reinvest_rate)</td>
<td>修正内部收益率。</td>
</tr>
<tr>
<td>nper(rate, pmt, pv[, fv, when])</td>
<td>计算定期付款的数量。</td>
</tr>
<tr>
<td>rate(nper, pmt, pv, fv[, when, guess, tol, …])</td>
<td>计算每期利率。</td>
</tr>
</tbody></table>
<hr>
<h1 id="11、功能程序设计"><a href="#11、功能程序设计" class="headerlink" title="11、功能程序设计"></a>11、功能程序设计</h1><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>apply_along_axis(func1d, axis, arr, *args, …)</td>
<td>沿给定轴将函数应用于一维切片。</td>
</tr>
<tr>
<td>apply_over_axes(func, a, axes)</td>
<td>在多个轴上重复应用一个函数。</td>
</tr>
<tr>
<td>vectorize(pyfunc[, otypes, doc, excluded, …])</td>
<td>广义函数类。</td>
</tr>
<tr>
<td>frompyfunc(func, nin, nout)</td>
<td>获取任意Python函数并返回NumPy ufunc。</td>
</tr>
<tr>
<td>piecewise(x, condlist, funclist, args, *kw)</td>
<td>评估分段定义的函数。</td>
</tr>
</tbody></table>
<hr>
<h1 id="12、索引"><a href="#12、索引" class="headerlink" title="12、索引"></a>12、索引</h1><h2 id="12-1-生成索引数组"><a href="#12-1-生成索引数组" class="headerlink" title="12.1 生成索引数组"></a>12.1 生成索引数组</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>_</td>
<td>将切片对象沿第二轴平移为串联。</td>
</tr>
<tr>
<td>r_</td>
<td>将切片对象沿第一轴平移为串联。</td>
</tr>
<tr>
<td>s_</td>
<td>建立数组索引元组的更好方法。</td>
</tr>
<tr>
<td>nonzero(a)</td>
<td>返回非零元素的索引。</td>
</tr>
<tr>
<td>where(condition, [x, y])</td>
<td>根据条件，返回x或y中的元素。</td>
</tr>
<tr>
<td>indices(dimensions[, dtype])</td>
<td>返回表示网格索引的数组。</td>
</tr>
<tr>
<td>ix_(*args)</td>
<td>从多个序列构建开放网格。</td>
</tr>
<tr>
<td>ogrid</td>
<td>返回开放多维“网格”的 nd_grid 实例。</td>
</tr>
<tr>
<td>ravel_multi_index(multi_index, dims[, mode, …])</td>
<td>将索引数组元组转换为平面索引数组，将边界模式应用于多索引。</td>
</tr>
<tr>
<td>unravel_index(indices, dims[, order])</td>
<td>将平面索引或平面索引数组转换为坐标数组元组。</td>
</tr>
<tr>
<td>diag_indices(n[, ndim])</td>
<td>返回索引以访问数组的主对角线。</td>
</tr>
<tr>
<td>diag_indices_from(arr)</td>
<td>返回索引以访问n维数组的主对角线。</td>
</tr>
<tr>
<td>mask_indices(n, mask_func[, k])</td>
<td>给定掩蔽函数，返回访问 (n，n) 个数组的索引。</td>
</tr>
<tr>
<td>tril_indices(n[, k, m])</td>
<td>返回 (n，m) 数组下三角形的索引。</td>
</tr>
<tr>
<td>tril_indices_from(arr[, k])</td>
<td>返回arr的下三角形的索引。</td>
</tr>
<tr>
<td>triu_indices(n[, k, m])</td>
<td>返回 (n，m) 数组上三角形的索引。</td>
</tr>
<tr>
<td>triu_indices_from(arr[, k])</td>
<td>返回arr上三角形的索引。</td>
</tr>
</tbody></table>
<h2 id="12-2-类似索引的操作"><a href="#12-2-类似索引的操作" class="headerlink" title="12.2 类似索引的操作"></a>12.2 类似索引的操作</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>take(a, indices[, axis, out, mode])</td>
<td>沿轴从数组中提取元素。</td>
</tr>
<tr>
<td>choose(a, choices[, out, mode])</td>
<td>从索引数组和一组可供选择的数组构造一个数组。</td>
</tr>
<tr>
<td>compress(condition, a[, axis, out])</td>
<td>沿给定轴返回阵列的选定切片。</td>
</tr>
<tr>
<td>diag(v[, k])</td>
<td>提取对角线或构造对角线数组。</td>
</tr>
<tr>
<td>diagonal(a[, offset, axis1, axis2])</td>
<td>返回指定的对角线。</td>
</tr>
<tr>
<td>select(condlist, choicelist[, default])</td>
<td>根据条件返回从choicelist中的元素中提取的数组。</td>
</tr>
<tr>
<td>lib.stride_tricks.as_strided(x[, shape, …])</td>
<td>以给定的形状和步幅创建阵列视图。</td>
</tr>
</tbody></table>
<h2 id="12-3-将数据插入数组"><a href="#12-3-将数据插入数组" class="headerlink" title="12.3 将数据插入数组"></a>12.3 将数据插入数组</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>place(arr, mask, vals)</td>
<td>根据条件值和输入值更改数组的元素。</td>
</tr>
<tr>
<td>put(a, ind, v[, mode])</td>
<td>用给定值替换数组的指定元素。</td>
</tr>
<tr>
<td>putmask(a, mask, values)</td>
<td>根据条件值和输入值更改数组的元素。</td>
</tr>
<tr>
<td>fill_diagonal(a, val[, wrap])</td>
<td>填充给定维度数组的主对角线。</td>
</tr>
</tbody></table>
<h2 id="12-4-迭代数组"><a href="#12-4-迭代数组" class="headerlink" title="12.4 迭代数组"></a>12.4 迭代数组</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>nditer</td>
<td>高效的多维迭代器对象对数组进行迭代。</td>
</tr>
<tr>
<td>ndenumerate(arr)</td>
<td>多维索引迭代器。</td>
</tr>
<tr>
<td>ndindex(*shape)</td>
<td>索引数组的N维迭代器对象。</td>
</tr>
<tr>
<td>flatiter</td>
<td>要在数组上迭代的平面迭代器对象。</td>
</tr>
<tr>
<td>lib.Arrayterator(var[, buf_size])</td>
<td>大数组缓冲迭代器。</td>
</tr>
</tbody></table>
<hr>
<h1 id="13、输入输出"><a href="#13、输入输出" class="headerlink" title="13、输入输出"></a>13、输入输出</h1><h2 id="13-1-NumPy二进制文件-NPY，NPZ"><a href="#13-1-NumPy二进制文件-NPY，NPZ" class="headerlink" title="13.1 NumPy二进制文件( NPY，NPZ )"></a>13.1 NumPy二进制文件( NPY，NPZ )</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>load(file[, mmap_mode, allow_pickle, …])</td>
<td>加载数组</td>
</tr>
<tr>
<td>save(file, arr[, allow_pickle, fix_imports])</td>
<td>将数组保存到 NumPy 中的二进制文件中。npy格式。</td>
</tr>
<tr>
<td>savez(file, args, *kwds)</td>
<td>将几个阵列保存到未压缩的单个文件中。npz格式。</td>
</tr>
<tr>
<td>savez_compressed(file, args, *kwds)</td>
<td>将几个数组压缩保存到单个文件中。npz格式。</td>
</tr>
</tbody></table>
<h2 id="13-2-文本文件"><a href="#13-2-文本文件" class="headerlink" title="13.2 文本文件"></a>13.2 文本文件</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>loadtxt(fname[, dtype, comments, delimiter, …])</td>
<td>从文本文件加载数据。</td>
</tr>
<tr>
<td>savetxt(fname, X[, fmt, delimiter, newline, …])</td>
<td>将数组保存到文本文件中。</td>
</tr>
<tr>
<td>genfromtxt(fname[, dtype, comments, …])</td>
<td>从文本文件加载数据，缺失值按指定处理。</td>
</tr>
<tr>
<td>fromregex(file, regexp, dtype[, encoding])</td>
<td>使用正则表达式解析从文本文件构造数组。</td>
</tr>
<tr>
<td>fromstring(string[, dtype, count, sep])</td>
<td>从字符串中的文本数据初始化的新一维数组。</td>
</tr>
<tr>
<td>ndarray.tofile(fid[, sep, format])</td>
<td>将数组以文本或二进制形式写入文件(默认)。</td>
</tr>
<tr>
<td>ndarray.tolist()</td>
<td>将数组作为(可能嵌套的)列表返回。</td>
</tr>
</tbody></table>
<h2 id="13-3-原始二进制文件"><a href="#13-3-原始二进制文件" class="headerlink" title="13.3 原始二进制文件"></a>13.3 原始二进制文件</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>fromfile(file[, dtype, count, sep])</td>
<td>从文本或二进制文件中的数据构造数组。</td>
</tr>
<tr>
<td>ndarray.tofile(fid[, sep, format])</td>
<td>将数组以文本或二进制形式写入文件(默认)。</td>
</tr>
</tbody></table>
<h2 id="13-4-字符串格式"><a href="#13-4-字符串格式" class="headerlink" title="13.4 字符串格式"></a>13.4 字符串格式</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>array2string(a[, max_line_width, precision, …])</td>
<td>返回数组的字符串表示形式。</td>
</tr>
<tr>
<td>array_repr(arr[, max_line_width, precision, …])</td>
<td>返回数组的字符串表示形式。</td>
</tr>
<tr>
<td>array_str(a[, max_line_width, precision, …])</td>
<td>返回数组中数据的字符串表示形式。</td>
</tr>
<tr>
<td>format_float_positional(x[, precision, …])</td>
<td>在位置符号中将浮点标量格式化为十进制字符串。</td>
</tr>
<tr>
<td>format_float_scientific(x[, precision, …])</td>
<td>在科学记数法中将浮点标量格式化为十进制字符串。</td>
</tr>
</tbody></table>
<h2 id="13-5-内存映射文件"><a href="#13-5-内存映射文件" class="headerlink" title="13.5 内存映射文件"></a>13.5 内存映射文件</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>memmap</td>
<td>创建存储到磁盘上二进制文件中存储的阵列的内存映射。</td>
</tr>
</tbody></table>
<h2 id="13-6-文本格式选项"><a href="#13-6-文本格式选项" class="headerlink" title="13.6 文本格式选项"></a>13.6 文本格式选项</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>set_printoptions([precision, threshold, …])</td>
<td>设置打印选项。</td>
</tr>
<tr>
<td>get_printoptions()</td>
<td>返回当前打印选项。</td>
</tr>
<tr>
<td>set_string_function(f[, repr])</td>
<td>设置一个Python函数，用于漂亮的打印数组。</td>
</tr>
</tbody></table>
<h2 id="13-7-基-n表示"><a href="#13-7-基-n表示" class="headerlink" title="13.7 基-n表示"></a>13.7 基-n表示</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>binary_repr(num[, width])</td>
<td>将输入数字的二进制表示形式返回为字符串。</td>
</tr>
<tr>
<td>base_repr(number[, base, padding])</td>
<td>返回给定基本系统中数字的字符串表示形式。</td>
</tr>
</tbody></table>
<h2 id="13-8-数据源"><a href="#13-8-数据源" class="headerlink" title="13.8 数据源"></a>13.8 数据源</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>DataSource([destpath])</td>
<td>一般资料来源档案(档案、http、FTP、…)。</td>
</tr>
</tbody></table>
<hr>
<h1 id="14、线性代数from-numpy-linalg-import"><a href="#14、线性代数from-numpy-linalg-import" class="headerlink" title="14、线性代数from numpy.linalg import..."></a>14、线性代数<code>from numpy.linalg import...</code></h1><h2 id="14-1-矩阵和向量乘积"><a href="#14-1-矩阵和向量乘积" class="headerlink" title="14.1 矩阵和向量乘积"></a>14.1 矩阵和向量乘积</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>dot(a, b[, out])</td>
<td>两个数组的点积。</td>
</tr>
<tr>
<td>linalg.multi_dot(arrays)</td>
<td>在单个函数调用中计算两个或多个数组的点积，同时自动选择最快的求值顺序。</td>
</tr>
<tr>
<td>vdot(a, b)</td>
<td>返回两个向量的点积。</td>
</tr>
<tr>
<td>inner(a, b)</td>
<td>两个数组的内积。</td>
</tr>
<tr>
<td>outer(a, b[, out])</td>
<td>计算两个向量的外积。</td>
</tr>
<tr>
<td>matmul(a, b[, out])</td>
<td>两个数组的矩阵乘积。</td>
</tr>
<tr>
<td>tensordot(a, b[, axes])</td>
<td>计算阵列 &gt;&#x3D; 1 - d的沿指定轴的张量点积</td>
</tr>
<tr>
<td>einsum(subscripts, *operands[, out, dtype, …])</td>
<td>评估操作数上的爱因斯坦求和约定。</td>
</tr>
<tr>
<td>einsum_path(subscripts, *operands[, optimize])</td>
<td>通过考虑中间数组的创建来评估einsum表达式的最低成本收缩顺序。</td>
</tr>
<tr>
<td>linalg.matrix_power(M, n)</td>
<td>将方阵提高到(整数)幂n</td>
</tr>
<tr>
<td>kron(a, b)</td>
<td>两个数组的kronecker乘积。</td>
</tr>
</tbody></table>
<h2 id="14-2-分解"><a href="#14-2-分解" class="headerlink" title="14.2 分解"></a>14.2 分解</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>linalg.cholesky(a)</td>
<td>乔利斯基分解。</td>
</tr>
<tr>
<td>linalg.qr(a[, mode])</td>
<td>计算矩阵的QR分解。</td>
</tr>
<tr>
<td>linalg.svd(a[, full_matrices, compute_uv])</td>
<td>奇异值分解。</td>
</tr>
</tbody></table>
<h2 id="14-3-矩阵特征值"><a href="#14-3-矩阵特征值" class="headerlink" title="14.3 矩阵特征值"></a>14.3 矩阵特征值</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>linalg.eig(a)</td>
<td>计算方阵的特征值和右特征向量。</td>
</tr>
<tr>
<td>linalg.eigh(a[, UPLO])</td>
<td>返回埃尔米特矩阵或对称矩阵的特征值和特征向量。</td>
</tr>
<tr>
<td>linalg.eigvals(a)</td>
<td>计算一般矩阵的特征值。</td>
</tr>
<tr>
<td>linalg.eigvalsh(a[, UPLO])</td>
<td>计算埃尔米特矩阵或实对称矩阵的特征值。</td>
</tr>
</tbody></table>
<h2 id="14-4-其他数字"><a href="#14-4-其他数字" class="headerlink" title="14.4 其他数字"></a>14.4 其他数字</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>linalg.norm(x[, ord, axis, keepdims])</td>
<td>矩阵或向量范数。</td>
</tr>
<tr>
<td>linalg.cond(x[, p])</td>
<td>计算矩阵的条件数。</td>
</tr>
<tr>
<td>linalg.det(a)</td>
<td>计算数组的行列式。</td>
</tr>
<tr>
<td>linalg.matrix_rank(M[, tol, hermitian])</td>
<td>用奇异值分解法求数组的矩阵秩</td>
</tr>
<tr>
<td>linalg.slogdet(a)</td>
<td>计算数组行列式的符号和(自然)对数。</td>
</tr>
<tr>
<td>trace(a[, offset, axis1, axis2, dtype, out])</td>
<td>沿数组对角线返回总和。</td>
</tr>
</tbody></table>
<h2 id="14-5-求解方程和逆矩阵"><a href="#14-5-求解方程和逆矩阵" class="headerlink" title="14.5 求解方程和逆矩阵"></a>14.5 求解方程和逆矩阵</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>linalg.solve(a, b)</td>
<td>求解线性矩阵方程或线性标量方程组。</td>
</tr>
<tr>
<td>linalg.tensorsolve(a, b[, axes])</td>
<td>求解张量方程</td>
</tr>
<tr>
<td>linalg.lstsq(a, b[, rcond])</td>
<td>将最小二乘解返回线性矩阵方程。</td>
</tr>
<tr>
<td>linalg.inv(a)</td>
<td>计算矩阵的(乘法)逆。</td>
</tr>
<tr>
<td>linalg.pinv(a[, rcond])</td>
<td>计算矩阵的(摩尔-彭罗斯)伪逆。</td>
</tr>
<tr>
<td>linalg.tensorinv(a[, ind])</td>
<td>计算N维数组的“逆”。</td>
</tr>
</tbody></table>
<hr>
<h1 id="15、逻辑运算"><a href="#15、逻辑运算" class="headerlink" title="15、逻辑运算"></a>15、逻辑运算</h1><h2 id="15-1-真值检验"><a href="#15-1-真值检验" class="headerlink" title="15.1 真值检验"></a>15.1 真值检验</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>all(a[, axis, out, keepdims])</td>
<td>测试沿给定轴的所有数组元素是否评估为True。</td>
</tr>
<tr>
<td>any(a[, axis, out, keepdims])</td>
<td>测试沿给定轴的任何数组元素是否评估为True。</td>
</tr>
</tbody></table>
<h2 id="15-2-数组内容"><a href="#15-2-数组内容" class="headerlink" title="15.2 数组内容"></a>15.2 数组内容</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>isfinite(x, &#x2F;[, out, where, casting, order, …])</td>
<td>测试元素的有限性(不是无穷大或不是数字)。</td>
</tr>
<tr>
<td>isinf(x, &#x2F;[, out, where, casting, order, …])</td>
<td>以元素方式测试正无穷大或负无穷大。</td>
</tr>
<tr>
<td>isnan(x, &#x2F;[, out, where, casting, order, …])</td>
<td>对NaN进行逐个元素的测试，并将结果返回为布尔数组。</td>
</tr>
<tr>
<td>isnat(x, &#x2F;[, out, where, casting, order, …])</td>
<td>逐个元素测试NaT (不是时间)，并将结果作为布尔数组返回。</td>
</tr>
<tr>
<td>isneginf(x[, out])</td>
<td>逐个元素测试负无穷大，结果返回为bool数组。</td>
</tr>
<tr>
<td>isposinf(x[, out])</td>
<td>测试元素为正无穷大，返回结果为bool数组。</td>
</tr>
</tbody></table>
<h2 id="15-3-阵列式测试"><a href="#15-3-阵列式测试" class="headerlink" title="15.3 阵列式测试"></a>15.3 阵列式测试</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>iscomplex(x)</td>
<td>返回bool数组，如果输入元素复杂，则返回True。</td>
</tr>
<tr>
<td>iscomplexobj(x)</td>
<td>检查复数类型或复数数组。</td>
</tr>
<tr>
<td>isfortran(a)</td>
<td>如果数组是Fortran连续的但不是C连续的，则返回True。</td>
</tr>
<tr>
<td>isreal(x)</td>
<td>返回bool数组，如果输入元素为实，则返回True。</td>
</tr>
<tr>
<td>isrealobj(x)</td>
<td>如果x不是复杂类型或复数数组，则返回True。</td>
</tr>
<tr>
<td>isscalar(num)</td>
<td>如果num的类型是标量类型，则返回True。</td>
</tr>
</tbody></table>
<h2 id="15-4-逻辑运算"><a href="#15-4-逻辑运算" class="headerlink" title="15.4 逻辑运算"></a>15.4 逻辑运算</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>logical_and(x1, x2, &#x2F;[, out, where, …])</td>
<td>逐元素计算x1和x2的真值。</td>
</tr>
<tr>
<td>logical_or(x1, x2, &#x2F;[, out, where, casting, …])</td>
<td>逐元素计算x1或x2的真值。</td>
</tr>
<tr>
<td>logical_not(x, &#x2F;[, out, where, casting, …])</td>
<td>不按x元素计算真值。</td>
</tr>
<tr>
<td>logical_xor(x1, x2, &#x2F;[, out, where, …])</td>
<td>逐元素计算x1 XOR x2的真值。</td>
</tr>
</tbody></table>
<h2 id="15-5-比较"><a href="#15-5-比较" class="headerlink" title="15.5 比较"></a>15.5 比较</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>allclose(a, b[, rtol, atol, equal_nan])</td>
<td>如果两个数组在容差内元素相等，则返回True。</td>
</tr>
<tr>
<td>isclose(a, b[, rtol, atol, equal_nan])</td>
<td>返回一个布尔数组，其中两个数组在容差内按元素相等。</td>
</tr>
<tr>
<td>array_equal(a1, a2)</td>
<td>如果两个数组具有相同的形状和元素，则为true，否则为False。</td>
</tr>
<tr>
<td>array_equiv(a1, a2)</td>
<td>如果输入数组形状一致且所有元素相等，则返回True。</td>
</tr>
<tr>
<td>greater(x1, x2, &#x2F;[, out, where, casting, …])</td>
<td>逐元素返回( x1 &gt; x2 )的真值。</td>
</tr>
<tr>
<td>greater_equal(x1, x2, &#x2F;[, out, where, …])</td>
<td>逐元素返回( x1 &gt;&#x3D; x2 )的真值。</td>
</tr>
<tr>
<td>less(x1, x2, &#x2F;[, out, where, casting, …])</td>
<td>逐元素返回( x1 &lt; x2 )的真值。</td>
</tr>
<tr>
<td>less_equal(x1, x2, &#x2F;[, out, where, casting, …])</td>
<td>逐元素返回( x1 &#x3D;&lt; x2 )的真值。</td>
</tr>
<tr>
<td>equal(x1, x2, &#x2F;[, out, where, casting, …])</td>
<td>按元素返回( x1 &#x3D;&#x3D; x2 )。</td>
</tr>
<tr>
<td>not_equal(x1, x2, &#x2F;[, out, where, casting, …])</td>
<td>返回( x1 !&#x3D; x2 )元素方式。</td>
</tr>
</tbody></table>
<hr>
<h1 id="16、矩阵库-from-numpy-matlib-import"><a href="#16、矩阵库-from-numpy-matlib-import" class="headerlink" title="16、矩阵库 from numpy.matlib import..."></a>16、矩阵库 <code>from numpy.matlib import...</code></h1><p>此模块包含numpy命名空间中的所有函数，只是返回的是matrix对象而不是ndarrays。</p>
<h2 id="16-1-在numpy命名空间并返回matrix函数"><a href="#16-1-在numpy命名空间并返回matrix函数" class="headerlink" title="16.1 在numpy命名空间并返回matrix函数"></a>16.1 在numpy命名空间并返回matrix函数</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>mat(data[, dtype])</td>
<td>将输入解释为矩阵。</td>
</tr>
<tr>
<td>matrix(data[, dtype, copy])</td>
<td>从类似阵列的物件或资料字串传回矩阵。</td>
</tr>
<tr>
<td>asmatrix(data[, dtype])</td>
<td>将输入解释为矩阵。</td>
</tr>
<tr>
<td>bmat(obj[, ldict, gdict])</td>
<td>从字符串、嵌套序列或数组构建矩阵对象。</td>
</tr>
</tbody></table>
<h2 id="16-2-MATLAB中的替换函数"><a href="#16-2-MATLAB中的替换函数" class="headerlink" title="16.2 MATLAB中的替换函数"></a>16.2 MATLAB中的替换函数</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>empty(shape[, dtype, order])</td>
<td>返回给定形状和类型的新矩阵，而不初始化条目。</td>
</tr>
<tr>
<td>zeros(shape[, dtype, order])</td>
<td>返回给定形状和类型的矩阵，用零填充。</td>
</tr>
<tr>
<td>ones(shape[, dtype, order])</td>
<td>一矩阵。</td>
</tr>
<tr>
<td>eye(n[, M, k, dtype, order])</td>
<td>返回对角线上为1、别处为0的矩阵。</td>
</tr>
<tr>
<td>identity(n[, dtype])</td>
<td>返回给定大小的平方单位矩阵。</td>
</tr>
<tr>
<td>repmat(a, m, n)</td>
<td>重复阵列或矩阵MxN次。</td>
</tr>
<tr>
<td>rand(*args)</td>
<td>返回给定形状的随机值矩阵。</td>
</tr>
<tr>
<td>randn(*args)</td>
<td>返回带有“标准正态”分布数据的随机矩阵。</td>
</tr>
</tbody></table>
<hr>
<h1 id="17、随机数"><a href="#17、随机数" class="headerlink" title="17、随机数"></a>17、随机数</h1><h2 id="17-1-简单随机数据"><a href="#17-1-简单随机数据" class="headerlink" title="17.1 简单随机数据"></a>17.1 简单随机数据</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>rand(d0, d1, …, dn)</td>
<td>给定形状中的随机值。</td>
</tr>
<tr>
<td>randn(d0, d1, …, dn)</td>
<td>从“标准正态”分布中返回一个或多个样本。</td>
</tr>
<tr>
<td>randint(low[, high, size, dtype])</td>
<td>返回从低(含)到高(含)的随机整数。</td>
</tr>
<tr>
<td>random_integers(low[, high, size])</td>
<td>NP . int类型的随机整数，介于低和高之间，包括在内。</td>
</tr>
<tr>
<td>random_sample([size])</td>
<td>返回半开区间 [0.0, 1.0) 中的随机浮动。</td>
</tr>
<tr>
<td>random([size])</td>
<td>返回半开区间 [0.0, 1.0) 中的随机浮动。</td>
</tr>
<tr>
<td>ranf([size])</td>
<td>返回半开区间 [0.0, 1.0) 中的随机浮动。</td>
</tr>
<tr>
<td>sample([size])</td>
<td>返回半开区间 [0.0, 1.0) 中的随机浮动。</td>
</tr>
<tr>
<td>choice(a[, size, replace, p])</td>
<td>从给定的一维数组生成随机样本</td>
</tr>
<tr>
<td>bytes(length)</td>
<td>返回随机字节。</td>
</tr>
</tbody></table>
<h2 id="17-2-排列"><a href="#17-2-排列" class="headerlink" title="17.2 排列"></a>17.2 排列</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>shuffle(x)</td>
<td>通过移动序列的内容就地修改序列。</td>
</tr>
<tr>
<td>permutation(x)</td>
<td>随机置换序列，或返回置换范围。</td>
</tr>
</tbody></table>
<h2 id="17-3-分布"><a href="#17-3-分布" class="headerlink" title="17.3 分布"></a>17.3 分布</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>beta(a, b[, size])</td>
<td>从Beta分布中抽取样本。</td>
</tr>
<tr>
<td>binomial(n, p[, size])</td>
<td>从二项分布中抽取样本。</td>
</tr>
<tr>
<td>chisquare(df[, size])</td>
<td>从卡方分布中抽取样本。</td>
</tr>
<tr>
<td>dirichlet(alpha[, size])</td>
<td>从Dirichlet分布中抽取样本。</td>
</tr>
<tr>
<td>exponential([scale, size])</td>
<td>从指数分布中抽取样本。</td>
</tr>
<tr>
<td>f(dfnum, dfden[, size])</td>
<td>从F分布中抽取样本。</td>
</tr>
<tr>
<td>gamma(shape[, scale, size])</td>
<td>从伽玛分布中抽取样本。</td>
</tr>
<tr>
<td>geometric(p[, size])</td>
<td>从几何分布中抽取样本。</td>
</tr>
<tr>
<td>gumbel([loc, scale, size])</td>
<td>从秋葵分布中抽取样本。</td>
</tr>
<tr>
<td>hypergeometric(ngood, nbad, nsample[, size])</td>
<td>从超几何分布中提取样本。</td>
</tr>
<tr>
<td>laplace([loc, scale, size])</td>
<td>从拉普拉斯分布或双指数分布中抽取具有指定位置(或平均值)和标度(衰减)的样本。</td>
</tr>
<tr>
<td>logistic([loc, scale, size])</td>
<td>从物流配送中抽取样本。</td>
</tr>
<tr>
<td>lognormal([mean, sigma, size])</td>
<td>从对数正态分布中抽取样本。</td>
</tr>
<tr>
<td>logseries(p[, size])</td>
<td>从对数级数分布中抽取样本。</td>
</tr>
<tr>
<td>multinomial(n, pvals[, size])</td>
<td>从多项式分布中抽取样本。</td>
</tr>
<tr>
<td>multivariate_normal(mean, cov[, size, …])</td>
<td>从多元正态分布中抽取随机样本。</td>
</tr>
<tr>
<td>negative_binomial(n, p[, size])</td>
<td>从负二项分布中抽取样本。</td>
</tr>
<tr>
<td>noncentral_chisquare(df, nonc[, size])</td>
<td>从非中心卡方分布中抽取样本。</td>
</tr>
<tr>
<td>noncentral_f(dfnum, dfden, nonc[, size])</td>
<td>从非中心F分布中抽取样本。</td>
</tr>
<tr>
<td>normal([loc, scale, size])</td>
<td>从正态(高斯)分布中抽取随机样本。</td>
</tr>
<tr>
<td>pareto(a[, size])</td>
<td>从Pareto II或Lomax分布中抽取具有特定形状的样本。</td>
</tr>
<tr>
<td>poisson([lam, size])</td>
<td>从泊松分布中抽取样本。</td>
</tr>
<tr>
<td>power(a[, size])</td>
<td>在[ 0，1 ]从正指数为a - 1的幂分布中抽取样本。</td>
</tr>
<tr>
<td>rayleigh([scale, size])</td>
<td>从瑞利分布中抽取样本。</td>
</tr>
<tr>
<td>standard_cauchy([size])</td>
<td>从模式&#x3D; 0的标准Cauchy分布中抽取样本。</td>
</tr>
<tr>
<td>standard_exponential([size])</td>
<td>从标准指数分布中抽取样本。</td>
</tr>
<tr>
<td>standard_gamma(shape[, size])</td>
<td>从标准伽马分布中抽取样本。</td>
</tr>
<tr>
<td>standard_normal([size])</td>
<td>从标准正态分布中抽取样本(平均值&#x3D; 0，stdev &#x3D; 1 )。</td>
</tr>
<tr>
<td>standard_t(df[, size])</td>
<td>从具有df自由度的标准学生t分布中抽取样本。</td>
</tr>
<tr>
<td>triangular(left, mode, right[, size])</td>
<td>从[左、右区间的三角形分布中抽取样本]。</td>
</tr>
<tr>
<td>uniform([low, high, size])</td>
<td>从均匀分布中抽取样本。</td>
</tr>
<tr>
<td>vonmises(mu, kappa[, size])</td>
<td>从冯·米塞斯分布中抽取样本。</td>
</tr>
<tr>
<td>wald(mean, scale[, size])</td>
<td>从瓦尔德分布或逆高斯分布中提取样本。</td>
</tr>
<tr>
<td>weibull(a[, size])</td>
<td>从威布尔分布中抽取样本。</td>
</tr>
<tr>
<td>zipf(a[, size])</td>
<td>从Zipf分发中抽取样本。</td>
</tr>
</tbody></table>
<h2 id="17-4-随机发生器"><a href="#17-4-随机发生器" class="headerlink" title="17.4 随机发生器"></a>17.4 随机发生器</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>RandomState([seed])</td>
<td>梅森捻线机伪随机数发生器的容器。</td>
</tr>
<tr>
<td>seed([seed])</td>
<td>给发电机播种。</td>
</tr>
<tr>
<td>get_state()</td>
<td>返回表示生成器内部状态的元组。</td>
</tr>
<tr>
<td>set_state(state)</td>
<td>从元组中设置生成器的内部状态。</td>
</tr>
</tbody></table>
<hr>
<h1 id="18、集合操作"><a href="#18、集合操作" class="headerlink" title="18、集合操作"></a>18、集合操作</h1><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>unique(ar[, return_index, return_inverse, …])</td>
<td>查找数组的唯一元素。</td>
</tr>
<tr>
<td>in1d(ar1, ar2[, assume_unique, invert])</td>
<td>测试一维数组的每个元素是否也存在于第二个数组中。</td>
</tr>
<tr>
<td>intersect1d(ar1, ar2[, assume_unique])</td>
<td>找到两个数组的交集。</td>
</tr>
<tr>
<td>isin(element, test_elements[, …])</td>
<td>计算 test_elements 中的元素，仅在元素上广播。</td>
</tr>
<tr>
<td>setdiff1d(ar1, ar2[, assume_unique])</td>
<td>找出两个数组的集合差。</td>
</tr>
<tr>
<td>setxor1d(ar1, ar2[, assume_unique])</td>
<td>查找两个数组的异或集。</td>
</tr>
<tr>
<td>union1d(ar1, ar2)</td>
<td>找到两个数组的并集。</td>
</tr>
</tbody></table>
<hr>
<h1 id="19、排序、搜索、计数"><a href="#19、排序、搜索、计数" class="headerlink" title="19、排序、搜索、计数"></a>19、排序、搜索、计数</h1><h2 id="19-1-整理"><a href="#19-1-整理" class="headerlink" title="19.1 整理"></a>19.1 整理</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>sort(a[, axis, kind, order])</td>
<td>返回数组的排序副本。</td>
</tr>
<tr>
<td>lexsort(keys[, axis])</td>
<td>使用键序列执行间接排序。</td>
</tr>
<tr>
<td>argsort(a[, axis, kind, order])</td>
<td>返回对数组进行排序的索引。</td>
</tr>
<tr>
<td>ndarray.sort([axis, kind, order])</td>
<td>就地排序数组。</td>
</tr>
<tr>
<td>msort(a)</td>
<td>返回沿第一轴排序的数组副本。</td>
</tr>
<tr>
<td>sort_complex(a)</td>
<td>首先使用实部，然后使用虚部对复杂数组进行排序。</td>
</tr>
<tr>
<td>partition(a, kth[, axis, kind, order])</td>
<td>返回数组的分区副本。</td>
</tr>
<tr>
<td>argpartition(a, kth[, axis, kind, order])</td>
<td>使用kind关键字指定的算法沿给定轴执行间接分区。</td>
</tr>
</tbody></table>
<h2 id="19-2-搜索"><a href="#19-2-搜索" class="headerlink" title="19.2 搜索"></a>19.2 搜索</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>argmax(a[, axis, out])</td>
<td>返回沿轴的最大值的索引。</td>
</tr>
<tr>
<td>nanargmax(a[, axis])</td>
<td>忽略NaNs返回指定轴上最大值的索引。</td>
</tr>
<tr>
<td>argmin(a[, axis, out])</td>
<td>返回沿轴的最小值的索引。</td>
</tr>
<tr>
<td>nanargmin(a[, axis])</td>
<td>忽略NaNs返回指定轴上最小值的索引。</td>
</tr>
<tr>
<td>argwhere(a)</td>
<td>查找非零数组元素的索引，按元素分组。</td>
</tr>
<tr>
<td>nonzero(a)</td>
<td>返回非零元素的索引。</td>
</tr>
<tr>
<td>flatnonzero(a)</td>
<td>返回在a的扁平版本中非零的索引</td>
</tr>
<tr>
<td>where(condition, [x, y])</td>
<td>根据条件，返回x或y中的元素。</td>
</tr>
<tr>
<td>searchsorted(a, v[, side, sorter])</td>
<td>查找应该插入元素以维持秩序的索引。</td>
</tr>
<tr>
<td>extract(condition, arr)</td>
<td>返回满足某些条件的数组元素。</td>
</tr>
</tbody></table>
<h2 id="19-3-计数"><a href="#19-3-计数" class="headerlink" title="19.3 计数"></a>19.3 计数</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>count_nonzero(a[, axis])</td>
<td>统计数组a中非零值的数量</td>
</tr>
</tbody></table>
<hr>
<h1 id="20、统计学"><a href="#20、统计学" class="headerlink" title="20、统计学"></a>20、统计学</h1><h2 id="20-1-次序统计"><a href="#20-1-次序统计" class="headerlink" title="20.1 次序统计"></a>20.1 次序统计</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>amin(a[, axis, out, keepdims])</td>
<td>沿轴返回数组的最小值或最小值。</td>
</tr>
<tr>
<td>amax(a[, axis, out, keepdims])</td>
<td>返回数组的最大值或沿轴的最大值。</td>
</tr>
<tr>
<td>nanmin(a[, axis, out, keepdims])</td>
<td>返回数组的最小值或沿轴的最小值，忽略任何南线。</td>
</tr>
<tr>
<td>nanmax(a[, axis, out, keepdims])</td>
<td>沿轴返回数组的最大值或最大值，忽略任何南线。</td>
</tr>
<tr>
<td>ptp(a[, axis, out])</td>
<td>沿轴的值范围(最大-最小)。</td>
</tr>
<tr>
<td>percentile(a, q[, axis, out, …])</td>
<td>沿指定轴计算数据的qth百分位。</td>
</tr>
<tr>
<td>nanpercentile(a, q[, axis, out, …])</td>
<td>计算沿指定轴的数据的qth百分位，而忽略nan值。</td>
</tr>
</tbody></table>
<h2 id="20-2-平均数和差异"><a href="#20-2-平均数和差异" class="headerlink" title="20.2 平均数和差异"></a>20.2 平均数和差异</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>median(a[, axis, out, overwrite_input, keepdims])</td>
<td>计算沿指定轴的中间值。</td>
</tr>
<tr>
<td>average(a[, axis, weights, returned])</td>
<td>沿指定轴计算加权平均值。</td>
</tr>
<tr>
<td>mean(a[, axis, dtype, out, keepdims])</td>
<td>沿指定轴计算算术平均值。</td>
</tr>
<tr>
<td>std(a[, axis, dtype, out, ddof, keepdims])</td>
<td>计算沿指定轴的标准偏差。</td>
</tr>
<tr>
<td>var(a[, axis, dtype, out, ddof, keepdims])</td>
<td>计算沿指定轴的方差。</td>
</tr>
<tr>
<td>nanmedian(a[, axis, out, overwrite_input, …])</td>
<td>计算沿指定轴的中间值，而忽略南社。</td>
</tr>
<tr>
<td>nanmean(a[, axis, dtype, out, keepdims])</td>
<td>沿指定轴计算算术平均值，忽略南社。</td>
</tr>
<tr>
<td>nanstd(a[, axis, dtype, out, ddof, keepdims])</td>
<td>计算沿指定轴的标准偏差，而忽略NaNs。</td>
</tr>
<tr>
<td>nanvar(a[, axis, dtype, out, ddof, keepdims])</td>
<td>计算沿指定轴的方差，而忽略NaNs。</td>
</tr>
</tbody></table>
<h2 id="20-3-相关"><a href="#20-3-相关" class="headerlink" title="20.3 相关"></a>20.3 相关</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>corrcoef(x[, y, rowvar, bias, ddof])</td>
<td>返回皮尔逊积-矩相关系数。</td>
</tr>
<tr>
<td>correlate(a, v[, mode])</td>
<td>两个一维序列的互相关。</td>
</tr>
<tr>
<td>cov(m[, y, rowvar, bias, ddof, fweights, …])</td>
<td>给定数据和权重，估计协方差矩阵。</td>
</tr>
</tbody></table>
<h2 id="20-4-直方图"><a href="#20-4-直方图" class="headerlink" title="20.4 直方图"></a>20.4 直方图</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>histogram(a[, bins, range, normed, weights, …])</td>
<td>计算一组数据的直方图。</td>
</tr>
<tr>
<td>histogram2d(x, y[, bins, range, normed, weights])</td>
<td>计算两个数据样本的二维直方图。</td>
</tr>
<tr>
<td>histogramdd(sample[, bins, range, normed, …])</td>
<td>计算一些数据的多维直方图。</td>
</tr>
<tr>
<td>bincount(x[, weights, minlength])</td>
<td>统计非负整数数组中每个值的出现次数。</td>
</tr>
<tr>
<td>digitize(x, bins[, right])</td>
<td>返回输入数组中每个值所属的箱的索引。</td>
</tr>
</tbody></table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://huanyuan.mobi">赖兴兵</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://huanyuan.mobi/202311/python/NumPy/NumPy%E5%87%BD%E6%95%B0%E9%80%9F%E6%9F%A5%E8%A1%A8%EF%BC%88markdown%EF%BC%89.html">http://huanyuan.mobi/202311/python/NumPy/NumPy函数速查表（markdown）.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://huanyuan.mobi" target="_blank">Jona's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AI/">AI</a><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/%E5%B8%B8%E7%94%A8API/">常用API</a><a class="post-meta__tags" href="/tags/NumPy/">NumPy</a></div><div class="post_share"><div class="social-share" data-image="/imgs/202311/20231123180847.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/imgs/wechat.png" target="_blank"><img class="post-qr-code-img" src="/imgs/wechat.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/imgs/alipay.png" target="_blank"><img class="post-qr-code-img" src="/imgs/alipay.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/202312/kotlin/Kotlin%E5%90%84%E7%A7%8D%E4%B8%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB.html" title="Kotlin各种主构造函数区别"><img class="cover" src="/imgs/c2.jpg" onerror="onerror=null;src='/imgs/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Kotlin各种主构造函数区别</div></div></a></div><div class="next-post pull-right"><a href="/202305/android/Android%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html" title="Android开发常见问题记录"><img class="cover" src="/imgs/c0.jpg" onerror="onerror=null;src='/imgs/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Android开发常见问题记录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/202303/ai/%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80AI%E4%BD%9C%E5%9B%BE%E7%A5%9E%E4%BD%9C%E5%93%81%E6%AC%A3%E8%B5%8F.html" title="文心一言AI作图神作品欣赏"><img class="cover" src="/imgs/202303/b4a94af7469e4140974d63217f914725.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-21</div><div class="title">文心一言AI作图神作品欣赏</div></div></a></div><div><a href="/202201/python/Pytorch%E5%AE%89%E8%A3%85%E4%B9%8BAnaconda%E5%AE%89%E8%A3%85.html" title="Pytorch安装之Anaconda安装"><img class="cover" src="/imgs/c1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-12</div><div class="title">Pytorch安装之Anaconda安装</div></div></a></div><div><a href="/202201/python/VS%20Code%E6%8F%90%E7%A4%BA%20conda%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98.html" title="VS Code提示Anaconda问题处理"><img class="cover" src="/imgs/c4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-14</div><div class="title">VS Code提示Anaconda问题处理</div></div></a></div><div><a href="/202201/python/Pytorch%E5%AE%89%E8%A3%85%E4%B9%8Bconda%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E5%87%86%E5%A4%87.html" title="Pytorch安装之conda国内镜像准备"><img class="cover" src="/imgs/c2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-13</div><div class="title">Pytorch安装之conda国内镜像准备</div></div></a></div><div><a href="/202304/opencv/1%E3%80%81%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E6%A6%82%E5%BF%B5%E3%80%81%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0.html" title="1、图像分割概念、原理和算法实现"><img class="cover" src="/imgs/c2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">1、图像分割概念、原理和算法实现</div></div></a></div><div><a href="/202304/opencv/0%E3%80%81vscode+python+opencv%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html" title="0、vscode+python+opencv环境配置"><img class="cover" src="/imgs/c5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-11</div><div class="title">0、vscode+python+opencv环境配置</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/imgs/avatar.jpg" onerror="this.onerror=null;this.src='/imgs/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">赖兴兵</div><div class="author-info__description">这个网站是我个人博客站点，分享一些自己平时工作生活中遇到或者学习的内容，内容包含Java后端技术体系，Android前端技术体系，软件工程师成长等等。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">36</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">24</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/jonathanlai"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/jonathanlai" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://twitter.com/JonnyLai85" target="_blank" title="Twitter"><i class="fa-brands fa-twitter"></i></a><a class="social-icon" href="https://facebook.com/jonathan.lai.1426" target="_blank" title="Facebook"><i class="fa-brands fa-facebook"></i></a><a class="social-icon" href="https://instagram.com/jonathanlai8511/" target="_blank" title="Instagram"><i class="fa-brands fa-square-instagram"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">放弃几年的Blog重新开始写了 ~:></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">1.</span> <span class="toc-text">1、创建数组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%94%A81%E5%92%8C0%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 用1和0创建数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E6%A0%B9%E6%8D%AE%E7%8E%B0%E6%9C%89%E6%95%B0%E6%8D%AE%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 根据现有数据创建数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%88%9B%E5%BB%BA%E8%AE%B0%E5%BD%95%E6%95%B0%E7%BB%84-np-rec"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 创建记录数组(np.rec)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E6%95%B0%E7%BB%84-np-char"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 创建字符数组(np.char)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E6%A0%B9%E6%8D%AE%E6%95%B0%E5%80%BC%E8%8C%83%E5%9B%B4%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 根据数值范围创建数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-%E5%88%9B%E5%BB%BA%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 创建特殊矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-%E5%88%9B%E5%BB%BA%E7%9F%A9%E9%98%B5"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 创建矩阵</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="toc-number">2.</span> <span class="toc-text">2、数组操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%A4%8D%E5%88%B6"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%94%B9%E5%8F%98%E5%BD%A2%E7%8A%B6"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 改变形状</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E7%BD%AE%E6%8D%A2%E5%9D%90%E6%A0%87%E8%BD%B4"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 置换坐标轴</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%94%B9%E5%8F%98%E7%BB%B4%E6%95%B0"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 改变维数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%94%B9%E5%8F%98%E6%95%B0%E7%BB%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 改变数组种类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E8%BF%9E%E6%8E%A5%E6%95%B0%E7%BB%84"><span class="toc-number">2.6.</span> <span class="toc-text">2.6 连接数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-%E5%88%86%E8%A3%82%E6%95%B0%E7%BB%84"><span class="toc-number">2.7.</span> <span class="toc-text">2.7 分裂数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-%E5%B9%B3%E9%93%BA%E6%95%B0%E7%BB%84"><span class="toc-number">2.8.</span> <span class="toc-text">2.8 平铺数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-%E6%B7%BB%E5%8A%A0%E5%92%8C%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">2.9.</span> <span class="toc-text">2.9 添加和删除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-10-%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E5%85%83%E7%B4%A0"><span class="toc-number">2.10.</span> <span class="toc-text">2.10 重新排列元素</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">3、二进制操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%85%83%E7%B4%A0%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 元素位操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%AD%97%E8%8A%82%E6%89%93%E5%8C%85"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 字节打包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 输出格式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.</span> <span class="toc-text">4、操作字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 字符串操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%AF%94%E8%BE%83"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%BF%A1%E6%81%AF"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 字符串信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E6%97%A5%E6%9C%9F%E6%94%AF%E6%8C%81"><span class="toc-number">5.</span> <span class="toc-text">5、日期支持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 日期时间支持函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E8%90%A5%E4%B8%9A%E6%97%A5%E5%8A%9F%E8%83%BD"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 营业日功能</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.</span> <span class="toc-text">6、数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 数据类型检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 创建数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 数据类型信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%B5%8B%E8%AF%95"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 数据类型测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E5%85%B6%E5%AE%83"><span class="toc-number">6.5.</span> <span class="toc-text">6.5 其它</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81%E5%8F%AF%E9%80%89%E7%9A%84Scipy%E5%8A%A0%E9%80%9Ffrom-numpy-dual-import"><span class="toc-number">7.</span> <span class="toc-text">7、可选的Scipy加速from numpy.dual import...</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 线性代数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E5%BF%AB%E9%80%9F%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 快速傅里叶变换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 特殊函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81%E6%B5%AE%E7%82%B9%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">8、浮点错误处理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9%E3%80%81%E7%A6%BB%E6%95%A3%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2from-numpy-fft-import"><span class="toc-number">9.</span> <span class="toc-text">9、离散傅里叶变换from numpy.fft import...</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-%E6%A0%87%E5%87%86%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 标准快速傅立叶变换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-%E5%AE%9EFFTs"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 实FFTs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-%E5%9F%83%E5%B0%94%E7%B1%B3%E7%89%B9%E5%BF%AB%E9%80%9F%E5%82%85%E7%AB%8B%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 埃尔米特快速傅立叶变换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-%E5%85%B6%E5%AE%83"><span class="toc-number">9.4.</span> <span class="toc-text">9.4 其它</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10%E3%80%81%E8%B4%A2%E5%8A%A1"><span class="toc-number">10.</span> <span class="toc-text">10、财务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11%E3%80%81%E5%8A%9F%E8%83%BD%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">11.</span> <span class="toc-text">11、功能程序设计</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12%E3%80%81%E7%B4%A2%E5%BC%95"><span class="toc-number">12.</span> <span class="toc-text">12、索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-%E7%94%9F%E6%88%90%E7%B4%A2%E5%BC%95%E6%95%B0%E7%BB%84"><span class="toc-number">12.1.</span> <span class="toc-text">12.1 生成索引数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-%E7%B1%BB%E4%BC%BC%E7%B4%A2%E5%BC%95%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">12.2.</span> <span class="toc-text">12.2 类似索引的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-%E5%B0%86%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E6%95%B0%E7%BB%84"><span class="toc-number">12.3.</span> <span class="toc-text">12.3 将数据插入数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-%E8%BF%AD%E4%BB%A3%E6%95%B0%E7%BB%84"><span class="toc-number">12.4.</span> <span class="toc-text">12.4 迭代数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13%E3%80%81%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">13.</span> <span class="toc-text">13、输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-NumPy%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6-NPY%EF%BC%8CNPZ"><span class="toc-number">13.1.</span> <span class="toc-text">13.1 NumPy二进制文件( NPY，NPZ )</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">13.2.</span> <span class="toc-text">13.2 文本文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3-%E5%8E%9F%E5%A7%8B%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">13.3.</span> <span class="toc-text">13.3 原始二进制文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-4-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F"><span class="toc-number">13.4.</span> <span class="toc-text">13.4 字符串格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-5-%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6"><span class="toc-number">13.5.</span> <span class="toc-text">13.5 内存映射文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-6-%E6%96%87%E6%9C%AC%E6%A0%BC%E5%BC%8F%E9%80%89%E9%A1%B9"><span class="toc-number">13.6.</span> <span class="toc-text">13.6 文本格式选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-7-%E5%9F%BA-n%E8%A1%A8%E7%A4%BA"><span class="toc-number">13.7.</span> <span class="toc-text">13.7 基-n表示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-8-%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">13.8.</span> <span class="toc-text">13.8 数据源</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14%E3%80%81%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0from-numpy-linalg-import"><span class="toc-number">14.</span> <span class="toc-text">14、线性代数from numpy.linalg import...</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1-%E7%9F%A9%E9%98%B5%E5%92%8C%E5%90%91%E9%87%8F%E4%B9%98%E7%A7%AF"><span class="toc-number">14.1.</span> <span class="toc-text">14.1 矩阵和向量乘积</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2-%E5%88%86%E8%A7%A3"><span class="toc-number">14.2.</span> <span class="toc-text">14.2 分解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3-%E7%9F%A9%E9%98%B5%E7%89%B9%E5%BE%81%E5%80%BC"><span class="toc-number">14.3.</span> <span class="toc-text">14.3 矩阵特征值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4-%E5%85%B6%E4%BB%96%E6%95%B0%E5%AD%97"><span class="toc-number">14.4.</span> <span class="toc-text">14.4 其他数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-5-%E6%B1%82%E8%A7%A3%E6%96%B9%E7%A8%8B%E5%92%8C%E9%80%86%E7%9F%A9%E9%98%B5"><span class="toc-number">14.5.</span> <span class="toc-text">14.5 求解方程和逆矩阵</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15%E3%80%81%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">15.</span> <span class="toc-text">15、逻辑运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-%E7%9C%9F%E5%80%BC%E6%A3%80%E9%AA%8C"><span class="toc-number">15.1.</span> <span class="toc-text">15.1 真值检验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-%E6%95%B0%E7%BB%84%E5%86%85%E5%AE%B9"><span class="toc-number">15.2.</span> <span class="toc-text">15.2 数组内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-3-%E9%98%B5%E5%88%97%E5%BC%8F%E6%B5%8B%E8%AF%95"><span class="toc-number">15.3.</span> <span class="toc-text">15.3 阵列式测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97"><span class="toc-number">15.4.</span> <span class="toc-text">15.4 逻辑运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-5-%E6%AF%94%E8%BE%83"><span class="toc-number">15.5.</span> <span class="toc-text">15.5 比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16%E3%80%81%E7%9F%A9%E9%98%B5%E5%BA%93-from-numpy-matlib-import"><span class="toc-number">16.</span> <span class="toc-text">16、矩阵库 from numpy.matlib import...</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1-%E5%9C%A8numpy%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%B9%B6%E8%BF%94%E5%9B%9Ematrix%E5%87%BD%E6%95%B0"><span class="toc-number">16.1.</span> <span class="toc-text">16.1 在numpy命名空间并返回matrix函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-2-MATLAB%E4%B8%AD%E7%9A%84%E6%9B%BF%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">16.2.</span> <span class="toc-text">16.2 MATLAB中的替换函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17%E3%80%81%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-number">17.</span> <span class="toc-text">17、随机数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-1-%E7%AE%80%E5%8D%95%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">17.1.</span> <span class="toc-text">17.1 简单随机数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-2-%E6%8E%92%E5%88%97"><span class="toc-number">17.2.</span> <span class="toc-text">17.2 排列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-3-%E5%88%86%E5%B8%83"><span class="toc-number">17.3.</span> <span class="toc-text">17.3 分布</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-4-%E9%9A%8F%E6%9C%BA%E5%8F%91%E7%94%9F%E5%99%A8"><span class="toc-number">17.4.</span> <span class="toc-text">17.4 随机发生器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18%E3%80%81%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">18.</span> <span class="toc-text">18、集合操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19%E3%80%81%E6%8E%92%E5%BA%8F%E3%80%81%E6%90%9C%E7%B4%A2%E3%80%81%E8%AE%A1%E6%95%B0"><span class="toc-number">19.</span> <span class="toc-text">19、排序、搜索、计数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#19-1-%E6%95%B4%E7%90%86"><span class="toc-number">19.1.</span> <span class="toc-text">19.1 整理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-2-%E6%90%9C%E7%B4%A2"><span class="toc-number">19.2.</span> <span class="toc-text">19.2 搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-3-%E8%AE%A1%E6%95%B0"><span class="toc-number">19.3.</span> <span class="toc-text">19.3 计数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20%E3%80%81%E7%BB%9F%E8%AE%A1%E5%AD%A6"><span class="toc-number">20.</span> <span class="toc-text">20、统计学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#20-1-%E6%AC%A1%E5%BA%8F%E7%BB%9F%E8%AE%A1"><span class="toc-number">20.1.</span> <span class="toc-text">20.1 次序统计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-2-%E5%B9%B3%E5%9D%87%E6%95%B0%E5%92%8C%E5%B7%AE%E5%BC%82"><span class="toc-number">20.2.</span> <span class="toc-text">20.2 平均数和差异</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-3-%E7%9B%B8%E5%85%B3"><span class="toc-number">20.3.</span> <span class="toc-text">20.3 相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-4-%E7%9B%B4%E6%96%B9%E5%9B%BE"><span class="toc-number">20.4.</span> <span class="toc-text">20.4 直方图</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/202312/kotlin/Kotlin%E5%90%84%E7%A7%8D%E4%B8%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB.html" title="Kotlin各种主构造函数区别"><img src="/imgs/c2.jpg" onerror="this.onerror=null;this.src='/imgs/404.jpg'" alt="Kotlin各种主构造函数区别"/></a><div class="content"><a class="title" href="/202312/kotlin/Kotlin%E5%90%84%E7%A7%8D%E4%B8%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB.html" title="Kotlin各种主构造函数区别">Kotlin各种主构造函数区别</a><time datetime="2023-12-04T02:11:44.092Z" title="发表于 2023-12-04 10:11:44">2023-12-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/202311/python/NumPy/NumPy%E5%87%BD%E6%95%B0%E9%80%9F%E6%9F%A5%E8%A1%A8%EF%BC%88markdown%EF%BC%89.html" title="NumPy函数速查表（markdown）"><img src="/imgs/202311/20231123180847.png" onerror="this.onerror=null;this.src='/imgs/404.jpg'" alt="NumPy函数速查表（markdown）"/></a><div class="content"><a class="title" href="/202311/python/NumPy/NumPy%E5%87%BD%E6%95%B0%E9%80%9F%E6%9F%A5%E8%A1%A8%EF%BC%88markdown%EF%BC%89.html" title="NumPy函数速查表（markdown）">NumPy函数速查表（markdown）</a><time datetime="2023-11-23T10:01:33.661Z" title="发表于 2023-11-23 18:01:33">2023-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/202305/android/Android%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html" title="Android开发常见问题记录"><img src="/imgs/c0.jpg" onerror="this.onerror=null;this.src='/imgs/404.jpg'" alt="Android开发常见问题记录"/></a><div class="content"><a class="title" href="/202305/android/Android%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95.html" title="Android开发常见问题记录">Android开发常见问题记录</a><time datetime="2023-05-05T02:12:21.251Z" title="发表于 2023-05-05 10:12:21">2023-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/202305/android/Android%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9F%A5%E7%9C%8B%E6%89%8B%E6%9C%BA%E6%9E%B6%E6%9E%84.html" title="Android用命令行查看手机架构"><img src="/imgs/c2.jpg" onerror="this.onerror=null;this.src='/imgs/404.jpg'" alt="Android用命令行查看手机架构"/></a><div class="content"><a class="title" href="/202305/android/Android%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%9F%A5%E7%9C%8B%E6%89%8B%E6%9C%BA%E6%9E%B6%E6%9E%84.html" title="Android用命令行查看手机架构">Android用命令行查看手机架构</a><time datetime="2023-05-04T03:39:52.538Z" title="发表于 2023-05-04 11:39:52">2023-05-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/202305/android/%E7%94%A8adb%E5%91%BD%E4%BB%A4%E6%B7%BB%E5%8A%A0%E3%80%81%E6%9B%BF%E6%8D%A2Android%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8.html" title="用adb命令添加、替换Android系统应用"><img src="/imgs/c4.jpg" onerror="this.onerror=null;this.src='/imgs/404.jpg'" alt="用adb命令添加、替换Android系统应用"/></a><div class="content"><a class="title" href="/202305/android/%E7%94%A8adb%E5%91%BD%E4%BB%A4%E6%B7%BB%E5%8A%A0%E3%80%81%E6%9B%BF%E6%8D%A2Android%E7%B3%BB%E7%BB%9F%E5%BA%94%E7%94%A8.html" title="用adb命令添加、替换Android系统应用">用adb命令添加、替换Android系统应用</a><time datetime="2023-05-04T02:57:26.155Z" title="发表于 2023-05-04 10:57:26">2023-05-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2018 - 2023 By 赖兴兵</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Stay Hungry, Stay Foolish</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>